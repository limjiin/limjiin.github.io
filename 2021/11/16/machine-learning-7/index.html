<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limjiin.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="머신 러닝을 위한 필수 전처리에 대해 배워보자!">
<meta property="og:type" content="article">
<meta property="og:title" content="머신러닝  7편">
<meta property="og:url" content="https://limjiin.github.io/2021/11/16/machine-learning-7/index.html">
<meta property="og:site_name" content="야무진의 기술 블로그">
<meta property="og:description" content="머신 러닝을 위한 필수 전처리에 대해 배워보자!">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-16T00:24:05.756Z">
<meta property="article:modified_time" content="2021-11-16T02:52:20.785Z">
<meta property="article:author" content="limjiin">
<meta property="article:tag" content="machine">
<meta property="article:tag" content="learning">
<meta property="article:tag" content="data">
<meta property="article:tag" content="preprocessing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://limjiin.github.io/2021/11/16/machine-learning-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>머신러닝  7편 | 야무진의 기술 블로그</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">야무진의 기술 블로그</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">데이터 마케터 짜그리이지만, 계속 해보겠습니다.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://limjiin.github.io/2021/11/16/machine-learning-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="limjiin">
      <meta itemprop="description" content="All stories about git, sql, python">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="야무진의 기술 블로그">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          머신러닝  7편
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-16 09:24:05 / Modified: 11:52:20" itemprop="dateCreated datePublished" datetime="2021-11-16T09:24:05+09:00">2021-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index"><span itemprop="name">machine-learning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/11/16/machine-learning-7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/11/16/machine-learning-7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>머신 러닝을 위한 필수 전처리에 대해 배워보자!</p>
<span id="more"></span>

<ol>
<li>데이터 파편화 문제 : 파일 자체가 나뉘어 저장된 경우</li>
</ol>
<ul>
<li><p>지도 학습 모델을 학습하려면 하나의 통합된 데이터 집합이 필요함</p>
</li>
<li><p>문제 정의 및 해결 방안</p>
<blockquote>
<p>센서, 로그, 거래 데이터 등 같이 크기가 매우 큰 데이터는 시간과 ID 등에 따라 분할되어 저장됨<br>pandas.concat 함수 사용<br>통합해야 하는 데이터가 많은 경우 빈 데이터프레임을 생성한 후 반복문을 활용하거나  데이터를 concat함수를 이용<br>pd.concat([df1, df2], ignore_index = True, axis=0)<br>axis : 0 이면 행, 1이면 열 이지만, 벡터와 행렬 형태에 따라 달라짐</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>결과</th>
<th>결과</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>벡터</td>
<td>행렬</td>
</tr>
<tr>
<td>axis</td>
<td>0</td>
<td>결과가 행 벡터</td>
<td>연산 과정이 행 기준</td>
</tr>
<tr>
<td>axis</td>
<td>1</td>
<td>결과가 열 벡터</td>
<td>연산 과정이 열 기준</td>
</tr>
</tbody></table>
<blockquote>
<p>os.listdir : 모든 파일명을 리스트 형태로 변환</p>
</blockquote>
<h4 id="concat을-이용한-데이터-병합"><a href="#concat을-이용한-데이터-병합" class="headerlink" title="concat을 이용한 데이터 병합"></a>concat을 이용한 데이터 병합</h4><pre>
<code>
import os
import pandas as pd

os.chdir(r"C:\Users\user\Downloads\") # 데이터 경로 설정

os.listdir("에너지 사용량 예측") # 파일 목록 확인

merged_df = pd.DataFrame() # 빈 데이터 프레임 생성
for file in os.listdir("에너지 사용량 예측"): # file이 에너지 사용량 예측 폴더 내에 있는 파일명을 순회
    # 5월 데이터는 제외하고 부른다고 가정
    if '5월' not in file and ".csv" in file:
        df = pd.read_csv("에너지 사용량 예측/" + file) # 주의: 현재 경로는 ../데이터이므로 에너지 사용량 예측 폴더를 명시해줘야 함
        merged_df = pd.concat([merged_df, df], axis = 0, ignore_index = True)

merged_df.sort_values('date', inplace = True) # 날짜 기준 정렬 수행 
</code>
</pre>


<ol start="2">
<li>데이터 파편화 문제 : 명시적인 키 변수가 있는 경우</li>
</ol>
<ul>
<li>문제 정의 및 해결 방안<blockquote>
<p>효율적인 데이터 베이스 관리를 위해, 잘 정제된 데이터 일지라도 데이터가 키 변수를 기준으로 나뉘어 저장되는 경우<br>SQL = JOIN, python = merge<br>일반적인 경우 해결이 어려우나 다양한 케이스가 존재할 수 있으므로 반드시 핵심을 기억하자</p>
</blockquote>
<ul>
<li>어느 컬럼이 키 변수 역할을 할 수 있는지 확인하고 키 변수를 통일</li>
<li>레코드의 단위를 명확히 해야 함</li>
</ul>
</li>
</ul>
<blockquote>
<p>관련 문법 : left, right, on, left_on, right_on, left_index, right_index</p>
</blockquote>
<h4 id="merge를-이용한-데이터-병헙"><a href="#merge를-이용한-데이터-병헙" class="headerlink" title="merge를 이용한 데이터 병헙"></a>merge를 이용한 데이터 병헙</h4><pre>
<code>
# 모듈 불러오기 및 데이터 경로 설정
import os
import pandas as pd
os.chdir(r"C:\Users\user\Downloads")

# merge 기본: on의 활용
df1 = pd.read_csv("Telco_churn_customer_churn.csv")
df2 = pd.read_csv("Telco_churn_customer_info.csv")

# 두 데이터프레임에서 이름이 같은 변수가 key 변수만 있더라도, on을 사용하는 것이 바람직함
merged_df = pd.merge(df1, df2, on = 'customerID')

# left_on과 right_on의 활용

df2.rename(&#123;"customerID":"ID"&#125;, axis = 1, inplace = True) # 연습을 위해 df2의 customerID 컬럼명을 ID로 변환

merged_df = pd.merge(df1, df2, left_on = ['customerID'], right_on = ['ID']) 
# left, right 순서를 반드시 고려해야 함
# on, left_on, right_on 키워드에 리스트 형태로 입력받을 수 있음 (여기서도 순서가 중요)

merged_df.drop('ID', axis = 1, inplace = True) # 키 컬럼 중 하나를 삭제해줘야 함
</code>
</pre>

<ol start="3">
<li>데이터 파편화 문제 : 포맷이 다른 키 변수가 있는 경우</li>
</ol>
<ul>
<li><p>참조 데이터가 필요 없는 경우의 병합</p>
<blockquote>
<p>시간과 날짜 컬럼 등은 데이터에 따라 포맷이 다른 경우가 잦다<br>키 변수의 포맷이 다른 두 데이터프레임에 대해 merge를 적용하면 비정상적으로 병합이 이뤄질 수 있으므로, 하나의 컬럼을 다른 컬럼의 포맷에 맞게 변경해주는 작업<br>Series.apply</p>
</blockquote>
</li>
<li><p>참조 데이터가 필요한 경우의 병합</p>
<blockquote>
<p>일정한 패턴(도로명 주소, 지번 주소, 회원명, 회원 번호)이 없이 포맷이 다른 경우 컬럼 값을 참조 데이터를 이용하여 변경해야 함<br>Series.to_dict() : index를 key로 data를 value로 하는 사전으로 변환<br>Series.replace(dict) : key와 같은 값을 value로 변환해줌<br>dict = {a:1, b:2, c:3}</p>
</blockquote>
</li>
</ul>
<h4 id="포맷이-다른-데이터-병합-1-참조-데이터가-필요없는-경우"><a href="#포맷이-다른-데이터-병합-1-참조-데이터가-필요없는-경우" class="headerlink" title="포맷이 다른 데이터 병합 (1) 참조 데이터가 필요없는 경우"></a>포맷이 다른 데이터 병합 (1) 참조 데이터가 필요없는 경우</h4><pre>
<code>
# 모듈 불러오기 및 데이터 경로 설정
import os
import pandas as pd
os.chdir(r"C:\Users\user\Downloads")

df1 = pd.read_csv("날짜포맷이다른데이터1.csv")
df2 = pd.read_csv("날짜포맷이다른데이터2.csv")

#df1의 날짜 타입을 df2의 날짜 타입으로 변경하는 함수 작성 및 적용
def date_type_converter(value):
    YYYY, MM, DD = value.split('-')
    return YYYY + "년 " + str(int(MM)) + "월 " + str(int(DD)) + "일"

df1['날짜'] = df1['날짜'].apply(date_type_converter)

# 데이터 병합
merged_df = pd.merge(df1, df2, on = '날짜')
</code>
</pre>

<h4 id="포맷이-다른-데이터-병합-2-참조-데이터가-필요한-경우"><a href="#포맷이-다른-데이터-병합-2-참조-데이터가-필요한-경우" class="headerlink" title="포맷이 다른 데이터 병합 (2) 참조 데이터가 필요한 경우"></a>포맷이 다른 데이터 병합 (2) 참조 데이터가 필요한 경우</h4><pre>
<code>
# 모듈 불러오기 및 데이터 경로 설정
import os
import pandas as pd
os.chdir(r"C:\Users\user\Downloads")

# 데이터 불러오기
ref_df = pd.read_csv("시승격정보.csv", encoding = "cp949")
df1 = pd.read_excel("인구수데이터.xlsx", sheet_name = "202006")
df2 = pd.read_excel("인구수데이터.xlsx", sheet_name = "201108")

# ref_df를 사전으로 변환
ref_dict = ref_df.set_index('승격전')['승격후'].to_dict() # 인덱스 설정 및 시리즈로 변환

# ref_dict을 이용하여 키 변수 값 변환
df2['행정구역'] = df2['행정구역'].replace(ref_dict)

# df1과 df2에 있는 변수명이 모두 같으므로, 변수명을 수정해야 함
df1.set_index("행정구역", inplace = True) # 행정 구역 변수명은 바꾸지 않기 위해, 인덱스로 설정
df2.set_index("행정구역", inplace = True) # 행정 구역 변수명은 바꾸지 않기 위해, 인덱스로 설정

df1 = df1.add_prefix("202006_")
df2 = df2.add_prefix("201108_")

merged_df = pd.merge(df1, df2, left_index = True, right_index = True)
</code>
</pre>

<ol start="4">
<li>데이터 파편화 문제 : 거리 기반 병합이 필요한 경우</li>
</ol>
<ul>
<li>문제 정의 및 해결 방안<blockquote>
<p>아파트 가격 예측 등 지역이 포함되는 문제에서 주소나 위치 변수 등을 기준으로 거리가 가까운 레코드 및 관련 통계치를 통합해야 하는 경우</p>
</blockquote>
<ul>
<li>거리 행렬을 생성</li>
<li>거리 행렬의 행 혹은 열 기준 최소 값을 가지는 인덱스를 바탕으로 이웃을 탐색</li>
<li>이웃을 기존 데이터에 부착하는 방식</li>
</ul>
</li>
</ul>
<blockquote>
<p>scipy.spatial.distance.cdist : 두 개의 행렬을 바탕으로 거리 행렬을 반환하는 함수<br>ndarray.argsort : 작은 값부터 순서대로 데이터의 위치를 반환하는 함수로 이웃을 찾는데 주로 활용되는 함수<br>axis 0이면 열별 위치를 1이면 행별 위치를 반환</p>
</blockquote>
<h4 id="거리-기반의-데이터-병합"><a href="#거리-기반의-데이터-병합" class="headerlink" title="거리 기반의 데이터 병합"></a>거리 기반의 데이터 병합</h4><pre>
<code>
import os
import pandas as pd
import numpy as np

os.chdir(r"C:\Users\user\Downloads")

# 아파트 관련 데이터 불러오기
df1 = pd.read_csv("2019년_서울_아파트매매_실거래가.csv", encoding = "cp949")
df2 = pd.read_csv("2019년_서울시_아파트주소.csv", encoding = "cp949")
__

# 데이터 병합
df = pd.merge(df1, df2,left_on = ['법정동', '도로명', '아파트'], right_on = ['읍면동명', '도로명', '건물명'])

df3 = pd.read_excel("지하철역_위경도.xlsx")
__

# 거리 행렬 생성을 위한 컬럼 추출
df_location = df[['경도', '위도']]
df3_location = df3[['경도', '위도']]

!pip install haversine 
# 위경도 거리 계산을 위한 모듈 설치

# 거리 행렬 생성
from scipy.spatial.distance import cdist
from haversine import haversine

dist_mat = cdist(df_location, df3_location, metric = haversine)
# 'euclidean', 'cityblock', 'jaccard'

dist_mat

close_subway_index = dist_mat.argsort()[:, 0] # axis = 0
df['가까운역'] = df3.iloc[close_subway_index]['역명'].values
# 새로운 시리즈를 만들 때는 list, ndarray를 사용하는 것이 바람직하다!

df['가까운역까지_거리'] = dist_mat[close_subway_index][:, 0]
__
</code>
</pre>

<ol start="5">
<li>데이터 파편화 문제 : 데이터 요약이 포함되는 경우</li>
</ol>
<ul>
<li>문제 정의 및 해결 방안<blockquote>
<p>보통 1:N 병합인 경우에 사용되며, 거래 데이터 및 로그 데이터와 병합하는 경우에 주로 사용<br>중복 레코드를 포함하는 데이터를 요약한 후 병합하는 방식으로 문제 해결<br>DataFrame.groupby() : 조건부 통계량(조건에 따른 대상의 통계량)을 계산하기 위한 함수로 머신러닝 또는 통계 분석에 자주 활용됨<br>df.groupby([‘성별’])[‘신장’].mean()</p>
</blockquote>
</li>
</ul>
<h4 id="데이터-요약이-포함되는-데이터-병합"><a href="#데이터-요약이-포함되는-데이터-병합" class="headerlink" title="데이터 요약이 포함되는 데이터 병합"></a>데이터 요약이 포함되는 데이터 병합</h4><pre>
<code>
import pandas as pd
import os

os.chdir(r"C:\Users\user\Downloads")

# 데이터 불러오기
demo_df = pd.read_csv("고객별_인구통계정보.csv", engine = "python", encoding='cp949')
purchasing_df = pd.read_csv("고객별_구매금액.csv", engine = 'python', encoding='cp949')

# 데이터 요약
purchasing_aggregated_df = purchasing_df.groupby('고객ID')['구매금액'].sum()
purchasing_aggregated_df.rename('구매금액합계') # 대상 변수의 이름이 그댈도 시리즈의 이름이 되어, 적절한 변수명으로 수정해줘야 함

# 데이터 병합 수행
merged_df = pd.merge(demo_df, purchasing_aggregated_df, left_on = '고객ID', right_index = True)

# 하나의 변수를 추가하는 경우에 주로 사용하는 테크닉
# demo_df['구매금액합계'] = demo_df['고객ID'].replace(purchasing_aggregated_df.to_dict())
</code>
</pre>

<ol start="6">
<li>결측치 문제</li>
</ol>
<ul>
<li><p>문제 정의</p>
<blockquote>
<p>데이터에 결측치가 있어 모델 학습 자체가 되지 않는 문제<br>NaN : 값이 있어야 하는 데 없는 결측으로 대체, 추정, 예측 등으로 처리<br>None : 값이 없는 게 값인 결측(예: 직업 - 백수)으로 새로운 값으로 정의하는 방식으로 처리<br>상황에 따른 처리 방법 선택이 매우 중요함</p>
</blockquote>
</li>
<li><p>용어 정의</p>
<blockquote>
<p>결측 레코드 : 결측치를 포함하는 레코드<br>결측치 비율 : 결측 레코드 수 / 전체 레코드 개수</p>
</blockquote>
</li>
<li><p>해결 방법 : 삭제</p>
<blockquote>
<p>행 단위 결측 삭제 : 결측 레코드를 삭제하는 매우 간단하지만 조건을 만족해야 함</p>
</blockquote>
<ul>
<li>결측이 없는 레코드가 모델을 학습하는데 충분해야 함</li>
<li>결측이 새로운 데이터에는 없어야 함</li>
</ul>
</li>
</ul>
<blockquote>
<p>열 단위 결측 삭제 : 결측 레코드를 포함하는 열을 삭제하는 매우 간단한 방법이지만 두 가지 조건을 만족해야 함<br>    - 소수 변수에 결측이 많이 포함되어 있음<br>    - 해당 변수들이 크게 중요하지 않음(by 도메인 지식)<br>    - Series / DataFrame.isnull : 결측이면 True, 아니면 False를 반환 : sum함수와 같이 사용하면 결측치 분포를 확인하는데 주로 사용<br>    - DataFrame.dropna : 결측치가 포함된 행이나 열을 제거하는데 사용 : axis 1이면 결측이 포함된 열을 삭제 0이면 행을 삭제 : any 결측이 하나라도 포함되면 삭제 : all 모든 값이 결측인 경우만 삭제</p>
</blockquote>
<ul>
<li>해결 방법 : 대표 및 근처 값으로 대체<blockquote>
<p>대표 값으로 대체 (SimpleImpute) : 가장 널리 사용되나 소수 특징에 결측이 쏠리거나 특징 간 상관성이 큰 경우에는 활용하기 부적절</p>
</blockquote>
<ul>
<li>sklearn을 이용한 전처리 모델</li>
<li>평가 데이터는 전처리 모델을 학습하는데 사용하지 않음에 주목</li>
<li>sklearn.impute.SimpleImputer : 결측이 있는 변수의 대표값으로 결측을 대체하는 인스턴스</li>
</ul>
</li>
</ul>
<blockquote>
<p>근처 값으로 대체 : 시계열 변수인 경우에 결측이 바로 이전 값 혹은 이후 값과 유사할 가능성이 높음<br>    - DataFrame.fillna : 결측치를 특정 값이나 방법으로 채우는 함수 : ffill(이전) bfill(이후)</p>
</blockquote>
<ul>
<li>결측치 예측 모델<blockquote>
<p>결측이 발생하지 않은 컬럼을 바탕으로 결측치를 예측하는 모델을 학습하고 활용하는 방법<br>활용 : 결측치 예측 모델은 어느 상황에서도 무난하게 활용할 수 있다.</p>
</blockquote>
<ul>
<li>결측이 소수 컬럼에 쏠리면 안된다</li>
<li>특징 간 관계가 존재해야 한다</li>
<li>다른 결측치 처리 방법에 비해 시간이 오래 소요된다</li>
</ul>
</li>
</ul>
<blockquote>
<p>sklearn.impute.KNNImputer : 결측이 아닌 값만 사용하여 이웃을 구한 뒤 이웃들의 값의 대표값으로 결측을 대체하는 결측치 예측 모델<br>    - n_neighbors : 이웃 수</p>
</blockquote>
<h4 id="결측치-확인-및-제거"><a href="#결측치-확인-및-제거" class="headerlink" title="결측치 확인 및 제거"></a>결측치 확인 및 제거</h4><pre>
<code>
import pandas as pd
import os
os.chdir(r"C:\Users\user\Downloads")

# 행 단위 삭제
# 데이터 불러오기
df = pd.read_csv("mammographic.csv")

# 특징과 라벨 분리
X = df.drop('Output', axis = 1)
Y = df['Output']

# 학습 데이터와 평가 데이터 분할
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

Train_X.isnull().sum(axis = 0) # 열별 결측치 개수 확인

Train_X.isnull().sum(axis = 0) / len(Train_X) # 열별 결측치 비율 확인
# 결측이 전체적으로 많은 편이 아니나, 모든 컬럼에 결측이 1회 이상 발생 => 열 삭제 불가

Train_X.dropna(inplace = True) # 결측이 포함된 레코드 제거
# Train_X = Train_X.dropna()

Test_X.dropna(inplace = True) # 결측이 포함된 레코드 제거 (주의: 새로 들어온 레코드의 결측이 있으면 처리하지 못함을 의미)

# 열 단위 삭제
# 데이터 불러오기
df = pd.read_csv("post_operative.csv")

# 특징과 라벨 분리
X = df.drop('Decision', axis = 1)
Y = df['Decision']

# 학습 데이터와 평가 데이터 분할
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

Train_X.head() # COMFORT 변수에 '?'로 결측이 표시되어 있음을 확인

import numpy as np
# 결측이 '?'로 표시되어 있음 => 데이터에 대한 이해가 없으면 적절히 처리가 안될 수 있음
Train_X.replace('?', np.nan).isnull().sum() / len(Train_X)

# 모든 결측이 COMFORT에 쏠렸으며, 해당 변수가 중요하지 않다는 도메인 지식 기반 하에 삭제
Train_X.dropna(axis = 1, inplace = True)


# Test_X = Test_X[Train_X.columns]
Test_X.drop('COMFORT', axis = 1, inplace = True) # Test_X에는 COMFORT가 결측이 없었을 수도 있으므로, drop을 이용하여 삭제

Train_X.isnull().sum(axis = 0)
</code>
</pre>

<h4 id="대표값을-활용한-결측치-대체"><a href="#대표값을-활용한-결측치-대체" class="headerlink" title="대표값을 활용한 결측치 대체"></a>대표값을 활용한 결측치 대체</h4><pre>
<code>
# 단순한 케이스: 모든 특징의 타입이 같은 경우
import pandas as pd
import os

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("cleveland.csv")

# 특징과 라벨 분리
X = df.drop('Output', axis = 1)
Y = df['Output']

# 학습 데이터와 평가 데이터로 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

# 결측치 확인
Train_X.isnull().sum()
# 결측치가 많지 않음
# 지워도 무방한 수치이지만, 새로 들어온 데이터에 결측이 있을 수도 있다는 도메인 지식이 있다고 가정

# 평균 상관 계수 확인 (주의: 모든 변수가 연속형이므로 가능한 접근)
Train_X.corr().sum() / (len(Train_X.columns) - 1)

# 수치가 높지 않다고 판단 => 특징 간 관계가 크지 않음 => 대표값 대체 활용 가능 판단

# 대표값을 활용한 결측치 대체
from sklearn.impute import SimpleImputer

# SimpleImputer 인스턴스화
SI = SimpleImputer(strategy = 'mean')

# 학습
SI.fit(Train_X)

# sklearn instance의 출력은 ndarray이므로 다시 DataFrame으로 바꿔줌
Train_X.isnull().sum()Train_X = pd.DataFrame(SI.transform(Train_X), columns = Train_X.columns)
Test_X = pd.DataFrame(SI.transform(Test_X), columns = Test_X.columns)

# 복잡한 케이스: 다른 타입의 특징이 있는 경우
df = pd.read_csv("saheart.csv")

# 특징과 라벨 분리
X = df.drop('Chd', axis = 1)
Y = df['Chd']

# 학습 데이터와 평가 데이터로 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

# 결측치 확인
Train_X.isnull().sum()
# 결측치가 많지 않음
# 지워도 무방한 수치이지만, 새로 들어온 데이터에 결측이 있을 수도 있다는 도메인 지식이 있다고 가정

# 평균 상관 계수 확인 (주의: 모든 변수가 연속형이므로 가능한 접근)
Train_X.corr().sum() / (len(Train_X.columns) - 1)

# 수치가 높지 않다고 판단 => 특징 간 관계가 크지 않음 => 대표값 대체 활용 가능 판단

# Famhist: 범주형 변수
# 그 외 변수: 연속형 변수

# 대표값을 평균을 사용할지, 최빈값을 사용할지 결정이 어려움 => 둘 다 사용해야 함
# 따라서 데이터를 분할해야 함

Train_X_cate = Train_X[['Famhist']]
Train_X_cont = Train_X.drop('Famhist', axis = 1)

Test_X_cate = Test_X[['Famhist']]
Test_X_cont = Test_X.drop('Famhist', axis = 1)

# 대표값을 활용한 결측치 대체
from sklearn.impute import SimpleImputer

# SimpleImputer 인스턴스화
SI_mode = SimpleImputer(strategy = 'most_frequent')
SI_mean = SimpleImputer(strategy = 'mean')

# 학습
SI_mode.fit(Train_X_cate)
SI_mean.fit(Train_X_cont)

# sklearn instance의 출력은 ndarray이므로 다시 DataFrame으로 바꿔줌
Train_X_cate = pd.DataFrame(SI_mode.transform(Train_X_cate),
                            columns = Train_X_cate.columns)

Test_X_cate = pd.DataFrame(SI_mode.transform(Test_X_cate),
                           columns = Test_X_cate.columns)

Train_X_cont = pd.DataFrame(SI_mean.transform(Train_X_cont),
                            columns = Train_X_cont.columns)

Test_X_cont = pd.DataFrame(SI_mean.transform(Test_X_cont),
                           columns = Test_X_cont.columns)

# 다시 두 데이터를 이어붙여야 함
Train_X = pd.concat([Train_X_cate, Train_X_cont], axis = 1)
Test_X = pd.concat([Test_X_cate, Test_X_cont], axis = 1)

Train_X.isnull().sum()

# Tip. 이진형 변수와 연속형 변수만 포함된 경우에는 SI_mean만 사용하여 결측치를 평균으로 대체한 뒤에,
# 이진형 변수에 대해서만 round 처리를 하면 하나의 인스턴스만 활용할 수 있음
</code>
</pre>

<h4 id="시계열-결측치-대체"><a href="#시계열-결측치-대체" class="headerlink" title="시계열 결측치 대체"></a>시계열 결측치 대체</h4><pre>
<code>
# 데이터를 train_test_split을 이용하여 임의로 분할한 경우에는 적용이 불가능
# 분할하기 전에 결측치 대체가 가능한 유일한 케이스

import pandas as pd
import os

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_excel("AirQuality.xlsx")

df.isnull().sum()

df = df.fillna(method = 'ffill').fillna(method = 'bfill')

df.isnull().sum()
</code>
</pre>

<h4 id="결측치-예측-모델-활용"><a href="#결측치-예측-모델-활용" class="headerlink" title="결측치 예측 모델 활용"></a>결측치 예측 모델 활용</h4><pre>
<code>
import os
import pandas as pd

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("mammographic.csv")

# 특징과 라벨 분리
X = df.drop('Output', axis = 1)
Y = df['Output']

# 학습 데이터와 평가 데이터 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

# 열별 결측치 비율 확인 => 그리 높지 않음을 확인
Train_X.isnull().sum() / len(Train_X)

# 특징 간 상관 계수 확인 => 평균적으로 40 ~ 50%로 매우 높음을 확인
Train_X.corr().sum() / len(Train_X.columns)

# KNN Imputer 인스턴스화
from sklearn.impute import KNNImputer
KI = KNNImputer(n_neighbors = 5)

# KNN Imputer 학습
KI.fit(Train_X)

# 결측 대체
Train_X = pd.DataFrame(KI.transform(Train_X), columns = Train_X.columns)
Test_X = pd.DataFrame(KI.transform(Test_X), columns = Test_X.columns)

Train_X.isnull().sum() / len(Train_X)

Test_X.isnull().sum() / len(Test_X)
</code>
</pre>

<ol start="7">
<li>문자 보다는 숫자 범주형 변수 문제</li>
</ol>
<ul>
<li><p>문제 정의</p>
<blockquote>
<p>데이터에 범주형 변수가 포함되어 있어 대다수의 지도 학습 모델이 학습되지 않거나 비정상적으로 학습되는 문제를 의미 : str, int, float<br>모델 학습을 위해 범주형 변수는 반드시 숫자로 변환되어야 하지만, 임의로 설정하는 것은 매우 부적절함<br>특히 코드화된 범주형 변수도 적절한 숫자로 변환해줘야 함</p>
</blockquote>
</li>
<li><p>범주형 변수 판별</p>
<blockquote>
<p>범주형 변수는 상태 공간의 크기가 유한한 변수<br>도메인이나 변수의 상태 공간을 바탕으로 판단<br>int 혹은 float 타입으로 정의된 변수는 반드시 연속형 변수가 아닐 수 있음</p>
</blockquote>
</li>
<li><p>범주형 변수 변환 방법 : 더미화</p>
<blockquote>
<p>가장 일반적인 변주형 변수를 변환하는 방법, 범주형 변수가 특정 값을 취하는지 여부를 나타내는 더미 변수를 생성하는 방법<br>장점 : 간편함<br>단점 : 차원의 저주, 희소성<br>Series.unique() : 상태 공간을 확인하는데 사용<br>feature_engine.categorical_encoders.OneHotCategoricalEncoder : 더미화를 위한 함수</p>
</blockquote>
<ul>
<li>pandas.get_dummies() : 새로 들어온 데이터 적용 불가</li>
</ul>
</li>
<li><p>범주형 변수 변환 방법 : 연속형 변수로 치환</p>
<blockquote>
<p>범주형 변수의 상태 공간 크기가 클 때, 더미화는 과하게 많은 변수를 추가해서 차원의 저주 문제로 이어질 수 있음<br>라벨 정보를 활용하여 범주 변수를 연속형 변수로 치환하면 기존 변수가 가지는 정보가 일부 손실될 수 있고 활용이 어렵다는 단점이 있으나, 차원의 크기가 변하지 않으며 더 효율적인 변수로 변환할 수 있다는 장점</p>
</blockquote>
</li>
</ul>
<h4 id="범주형-변수-처리"><a href="#범주형-변수-처리" class="headerlink" title="범주형 변수 처리"></a>범주형 변수 처리</h4><pre>
<code>
import pandas as pd
import os
os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("car-good.csv")

# 특징과 라벨 분리
X = df.drop('Class', axis = 1)
Y = df['Class']

# 학습 데이터와 평가 데이터 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

Train_Y.value_counts()

# 문자 라벨을 숫자로 치환
Train_Y.replace(&#123;"negative":-1, "positive":1&#125;, inplace = True)
Test_Y.replace(&#123;"negative":-1, "positive":1&#125;, inplace = True)

Train_X.head() # Buying, Maint, Lug_boot, safety 변수가 범주형 변수로 판단됨

# 자세한 범주형 변수 판별 => 모든 변수가 범주형임을 확인
for col in Train_X.columns:
    print(col, len(Train_X[col].unique()))

# 더미화를 이용한 범주 변수 처리
Train_X = Train_X.astype(str) # 모든 변수가 범주이므로, 더미화를 위해 전부 string 타입으로 변환

from feature_engine import OneHotCategoricalEncoder as OHE
dummy_model = OHE(variables = Train_X.columns.tolist(),
                 drop_last = True)

dummy_model.fit(Train_X)

d_Train_X = dummy_model.transform(Train_X)
d_Test_X = dummy_model.transform(Test_X)

# 더미화를 한 뒤의 모델 테스트
from sklearn.neighbors import KNeighborsClassifier as KNN
model = KNN().fit(d_Train_X, Train_Y)
pred_Y = model.predict(d_Test_X)

from sklearn.metrics import f1_score
f1_score(Test_Y, pred_Y)

# 연속형 변수로 치환
Train_df = pd.concat([Train_X, Train_Y], axis = 1)
for col in Train_X.columns: # 보통은 범주 변수만 순회
    temp_dict = Train_df.groupby(col)['Class'].mean().to_dict() # col에 따른 Class의 평균을 나타내는 사전 (replace를 쓰기 위해, 사전으로 만듦)
    Train_df[col] = Train_df[col].replace(temp_dict) # 변수 치환
    Test_X[col] = Test_X[col].astype(str).replace(temp_dict) # 테스트 데이터도 같이 치환해줘야 함 (나중에 활용하기 위해서는 저장도 필요)

Train_X = Train_df.drop('Class', axis = 1)
Train_Y = Train_df['Class']

# 치환한 뒤의 모델 테스트
model = KNN().fit(Train_X, Train_Y)
pred_Y = model.predict(Test_X)

f1_score(Test_Y, pred_Y)


# 라벨을 고려한 전처리이므로 더미화보다 좋은 결과가 나왔음 => 차원도 줄고 성능 상에 이점이 있으나,
</code>
</pre>

<h4 id="특징-추가-실습"><a href="#특징-추가-실습" class="headerlink" title="특징 추가 실습"></a>특징 추가 실습</h4><pre>
<code>
import pandas as pd
import os
os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("Combined_Cycle_Power_Plant.csv")

# 특징과 라벨 분리
X = df.drop('EP', axis = 1)
Y = df['EP']

# 신규 데이터 생성
X_added = X.copy() # 특징이 추가된 데이터를 부착할 데이터

import numpy as np
# 로그와 제곱 관련 변수만 추가
for col in X.columns:
    X_added[col + '_squared'] = X[col] ** 2
    X_added[col + '_log'] = np.log(X[col])

from sklearn.model_selection import cross_val_score
from sklearn.linear_model import LinearRegression as LR

# 5겹 교차 검증 기반의 평가 수행
X_score = cross_val_score(LR(), X, Y, cv = 5, scoring = 'neg_mean_absolute_error').mean()
X_added_score = cross_val_score(LR(), X_added, Y, cv = 5, scoring = 'neg_mean_absolute_error').mean()

print("특징 추가 전:&#123;&#125;, 특징 추가 후:&#123;&#125;".format(X_score, X_added_score))
</code>
</pre>

<h4 id="이상치-탐색-및-제거-1-IQR-RULE-활용"><a href="#이상치-탐색-및-제거-1-IQR-RULE-활용" class="headerlink" title="이상치 탐색 및 제거 (1) IQR RULE 활용"></a>이상치 탐색 및 제거 (1) IQR RULE 활용</h4><pre>
<code>
import pandas as pd
import os

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("glass.csv")

# 특징과 라벨 분리
X = df.drop(['Glass_type'], axis = 1)
Y = df['Glass_type']

# 학습 데이터와 평가 데이터 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)
Train_X.shape

import numpy as np
def IQR_rule(val_list): # 한 특징에 포함된 값 (열 벡터)
    # IQR 계산
    Q1 = np.quantile(val_list, 0.25)
    Q3 = np.quantile(val_list, 0.75)
    IQR = Q3 - Q1

    # IQR rule을 위배하지 않는 bool list 계산 (True: 이상치 X, False: 이상치 O)
    not_outlier_condition = (Q3 + 1.5 * IQR > val_list) & (Q1 - 1.5 * IQR < val_list)
    return not_outlier_condition

conditions = Train_X.apply(IQR_rule) # apply를 이용하여 모든 컬럼에 IQR rule 함수 적용
conditions

total_condition = conditions.sum(axis = 1) == len(Train_X.columns) # 하나라도 IQR 규칙을 위반하는 요소를 갖는 레코드를 제거하기 위한 규칙
Train_X = Train_X.loc[total_condition] # 이상치 제거

Train_X.shape #  50개 삭제됨
</code>
</pre>

<h4 id="이상치-탐색-및-제가-2-DBSCAN-활용"><a href="#이상치-탐색-및-제가-2-DBSCAN-활용" class="headerlink" title="이상치 탐색 및 제가 (2) DBSCAN 활용"></a>이상치 탐색 및 제가 (2) DBSCAN 활용</h4><pre>
<code>
import pandas as pd
import os
import numpy as np

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("glass.csv")

# 특징과 라벨 분리
X = df.drop(['Glass_type'], axis = 1)
Y = df['Glass_type']

# 학습 데이터와 평가 데이터 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)
Train_X.shape

DM = cdist(Train_X, Train_X) # 거리 행렬 => DBSCAN의 파라미터를 설정하기 위함
np.quantile(DM, 0.1) # 샘플 간 거리의 10% quantile이 0.6622정도임을 확인

from scipy.spatial.distance import cdist
from sklearn.cluster import DBSCAN

cluster_model = DBSCAN(eps = 0.67, min_samples = 3).fit(Train_X)
print(sum(cluster_model.labels_ == -1))
# 38개가 이상치로 판단 => 이정도면 너무 많은 양이 아닌가?? => 파라미터 조정

cluster_model = DBSCAN(eps = 2, min_samples = 3).fit(Train_X)
print(sum(cluster_model.labels_ == -1)) # 10개 정도면 괜찮은 양이라고 판단하여 삭제 수행

Train_X = Train_X[cluster_model.labels_ != -1]

Train_X.shape
</code>
</pre>

<h4 id="특징-간-상관관계-제거"><a href="#특징-간-상관관계-제거" class="headerlink" title="특징 간 상관관계 제거"></a>특징 간 상관관계 제거</h4><pre>
<code>
import pandas as pd
import os

os.chdir(r"C:\Users\user\Downloads")

df = pd.read_csv("abalone.csv")

# 특징과 라벨 분리
X = df.drop(['Age'], axis = 1)
Y = df['Age']

# 학습 데이터와 평가 데이터 분리
from sklearn.model_selection import train_test_split
Train_X, Test_X, Train_Y, Test_Y = train_test_split(X, Y)

Train_X.corr() # 특징 간 상관 행렬 출력 => 얼핏봐도 특징 간 선형 관계가 존재

# VIF 기준 특징 선택

# VIF 계산
from sklearn.linear_model import LinearRegression as LR
VIF_dict = dict()
for col in Train_X.columns:
    model = LR().fit(Train_X.drop([col], axis = 1), Train_X[col])
    r2 = model.score(Train_X.drop([col], axis = 1), Train_X[col]) # LinearRegression의 score가 r2 점수임
    VIF = 1 / (1 - r2)
    VIF_dict[col] = VIF

VIF_dict # Height를 제외하곤 VIF가 모두 높으므로, 이러한 상황에서는 사실 PCA를 사용하는 것이 바람직

from sklearn.neural_network import MLPRegressor as MLP
from sklearn.metrics import mean_absolute_error as MAE

# 전체 특징을 모두 사용하였을 때
model = MLP(random_state = 2313, max_iter = 500)
model.fit(Train_X, Train_Y)
pred_Y = model.predict(Test_X)
score = MAE(Test_Y, pred_Y)
print(score)

# VIF 점수가 30점 미만인 특징만 사용하였을 때
selected_features = [key for key, val in VIF_dict.items() if val < 30]
model = MLP(random_state = 2313, max_iter = 500)
model.fit(Train_X[selected_features], Train_Y)
pred_Y = model.predict(Test_X[selected_features])
score = MAE(Test_Y, pred_Y)
print(score)

# PCA 사용
from sklearn.decomposition import PCA
PCA_model = PCA(n_components = 3).fit(Train_X)

Train_Z = PCA_model.transform(Train_X)
Test_Z = PCA_model.transform(Test_X)

print(Train_Z.shape)

model = MLP(random_state = 2313, max_iter = 500)
model.fit(Train_Z, Train_Y)
pred_Y = model.predict(Test_Z)
score = MAE(Test_Y, pred_Y)
print(score)
</code>
</pre>

<h4 id="변수-치우침-제거"><a href="#변수-치우침-제거" class="headerlink" title="변수 치우침 제거"></a>변수 치우침 제거</h4><pre>
<code>
# 데이터 경로 설정 및 데이터 불러오기
import os
os.chdir(r"C:\Users\user\Downloads")

import pandas as pd
df = pd.read_csv("Sonar_Mines_Rocks.csv")
</code>
</pre>

<h4 id="스케일링"><a href="#스케일링" class="headerlink" title="스케일링"></a>스케일링</h4><pre>
<code>
</code>
</pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/machine/" rel="tag"># machine</a>
              <a href="/tags/learning/" rel="tag"># learning</a>
              <a href="/tags/data/" rel="tag"># data</a>
              <a href="/tags/preprocessing/" rel="tag"># preprocessing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/machine-learning-6/" rel="prev" title="머신러닝  6편">
      <i class="fa fa-chevron-left"></i> 머신러닝  6편
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#concat%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%95%A9"><span class="nav-number">1.</span> <span class="nav-text">concat을 이용한 데이터 병합</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%97%99"><span class="nav-number">2.</span> <span class="nav-text">merge를 이용한 데이터 병헙</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8F%AC%EB%A7%B7%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%95%A9-1-%EC%B0%B8%EC%A1%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%95%84%EC%9A%94%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0"><span class="nav-number">3.</span> <span class="nav-text">포맷이 다른 데이터 병합 (1) 참조 데이터가 필요없는 경우</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8F%AC%EB%A7%B7%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%95%A9-2-%EC%B0%B8%EC%A1%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0"><span class="nav-number">4.</span> <span class="nav-text">포맷이 다른 데이터 병합 (2) 참조 데이터가 필요한 경우</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B1%B0%EB%A6%AC-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%95%A9"><span class="nav-number">5.</span> <span class="nav-text">거리 기반의 데이터 병합</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9A%94%EC%95%BD%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%98%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%91%ED%95%A9"><span class="nav-number">6.</span> <span class="nav-text">데이터 요약이 포함되는 데이터 병합</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B2%B0%EC%B8%A1%EC%B9%98-%ED%99%95%EC%9D%B8-%EB%B0%8F-%EC%A0%9C%EA%B1%B0"><span class="nav-number">7.</span> <span class="nav-text">결측치 확인 및 제거</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%8C%80%ED%91%9C%EA%B0%92%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B2%B0%EC%B8%A1%EC%B9%98-%EB%8C%80%EC%B2%B4"><span class="nav-number">8.</span> <span class="nav-text">대표값을 활용한 결측치 대체</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%8B%9C%EA%B3%84%EC%97%B4-%EA%B2%B0%EC%B8%A1%EC%B9%98-%EB%8C%80%EC%B2%B4"><span class="nav-number">9.</span> <span class="nav-text">시계열 결측치 대체</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B2%B0%EC%B8%A1%EC%B9%98-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8-%ED%99%9C%EC%9A%A9"><span class="nav-number">10.</span> <span class="nav-text">결측치 예측 모델 활용</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%B2%94%EC%A3%BC%ED%98%95-%EB%B3%80%EC%88%98-%EC%B2%98%EB%A6%AC"><span class="nav-number">11.</span> <span class="nav-text">범주형 변수 처리</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8A%B9%EC%A7%95-%EC%B6%94%EA%B0%80-%EC%8B%A4%EC%8A%B5"><span class="nav-number">12.</span> <span class="nav-text">특징 추가 실습</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%9D%B4%EC%83%81%EC%B9%98-%ED%83%90%EC%83%89-%EB%B0%8F-%EC%A0%9C%EA%B1%B0-1-IQR-RULE-%ED%99%9C%EC%9A%A9"><span class="nav-number">13.</span> <span class="nav-text">이상치 탐색 및 제거 (1) IQR RULE 활용</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%9D%B4%EC%83%81%EC%B9%98-%ED%83%90%EC%83%89-%EB%B0%8F-%EC%A0%9C%EA%B0%80-2-DBSCAN-%ED%99%9C%EC%9A%A9"><span class="nav-number">14.</span> <span class="nav-text">이상치 탐색 및 제가 (2) DBSCAN 활용</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8A%B9%EC%A7%95-%EA%B0%84-%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%9C%EA%B1%B0"><span class="nav-number">15.</span> <span class="nav-text">특징 간 상관관계 제거</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%B3%80%EC%88%98-%EC%B9%98%EC%9A%B0%EC%B9%A8-%EC%A0%9C%EA%B1%B0"><span class="nav-number">16.</span> <span class="nav-text">변수 치우침 제거</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81"><span class="nav-number">17.</span> <span class="nav-text">스케일링</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">limjiin</p>
  <div class="site-description" itemprop="description">All stories about git, sql, python</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/limjiin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limjiin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:limjiin0413@gmail.com" title="E-Mail → mailto:limjiin0413@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.naver.com/lljin0413" title="Blog → https:&#x2F;&#x2F;blog.naver.com&#x2F;lljin0413" rel="noopener" target="_blank"><i class="fab fa-blog fa-fw"></i>Blog</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/ji_in_l" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;ji_in_l" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">limjiin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jin.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://limjiin.github.io/2021/11/16/machine-learning-7/";
    this.page.identifier = "2021/11/16/machine-learning-7/";
    this.page.title = "머신러닝  7편";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://jin.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
