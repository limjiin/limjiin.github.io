<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limjiin.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="기본적인 머신 러닝 모형을 배우기 전에 가장 중요한 데이터 핸들링에 대해  배워보자!">
<meta property="og:type" content="article">
<meta property="og:title" content="머신러닝  5편">
<meta property="og:url" content="https://limjiin.github.io/2021/11/15/machine-learning-5/index.html">
<meta property="og:site_name" content="야무진의 기술 블로그">
<meta property="og:description" content="기본적인 머신 러닝 모형을 배우기 전에 가장 중요한 데이터 핸들링에 대해  배워보자!">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-15T00:26:57.217Z">
<meta property="article:modified_time" content="2021-11-16T00:27:15.069Z">
<meta property="article:author" content="limjiin">
<meta property="article:tag" content="machine">
<meta property="article:tag" content="learning">
<meta property="article:tag" content="data">
<meta property="article:tag" content="handling">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://limjiin.github.io/2021/11/15/machine-learning-5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>머신러닝  5편 | 야무진의 기술 블로그</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">야무진의 기술 블로그</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">데이터 마케터 짜그리이지만, 계속 해보겠습니다.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://limjiin.github.io/2021/11/15/machine-learning-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="limjiin">
      <meta itemprop="description" content="All stories about git, sql, python">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="야무진의 기술 블로그">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          머신러닝  5편
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-15 09:26:57" itemprop="dateCreated datePublished" datetime="2021-11-15T09:26:57+09:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-16 09:27:15" itemprop="dateModified" datetime="2021-11-16T09:27:15+09:00">2021-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/machine-learning/" itemprop="url" rel="index"><span itemprop="name">machine-learning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/11/15/machine-learning-5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/11/15/machine-learning-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>기본적인 머신 러닝 모형을 배우기 전에 가장 중요한 데이터 핸들링에 대해  배워보자!</p>
<span id="more"></span>

<ol>
<li>데이터 전처리는 왜 중요할까?</li>
</ol>
<ul>
<li><p>현실 데이터는 분석 목적에 맞게 정리되어 있지 않아, 데이터 분석 기법을 그대로 적용하기 매우 어렵다</p>
</li>
<li><p>데이터 분석에 소요되는 시간</p>
<blockquote>
<p>모든 데이터 분석 프로젝트에서 데이터 전처리는 필수적인 과정이며, 많은 분석가들이 가장 많은 시간을 투입함<br>전체 분석 시간의 79%를 데이터 처리에 사용함</p>
</blockquote>
</li>
<li><p>데이터 전처리의 주요 효과</p>
<blockquote>
<p>효율적인 분석을 가능하게 해준다<br>불필요한 정보를 제거함으로써 인사이트를 얻는데 도움이 된다.<br>머신러닝 모델의 성능을 향상시킨다</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>데이터 전처리를 잘하는 방법</li>
</ol>
<ul>
<li><p>경험을 쌓아라</p>
</li>
<li><p>결과를 생각하여 : 전처리된 데이터의 구조를 미리 생각해야 불필요한 피드백 루프를 막을 수 있음</p>
</li>
<li><p>처리 과정을 생각하라 : 원 데이터를 결과 데이터로 바꾸기 위한 과정을 단계별로 정의해야 함</p>
</li>
<li><p>검색 능력을 쌓아라 : 검색 쿼리 : 파이썬, 모듈, How, 내용</p>
</li>
</ul>
<ol start="3">
<li>리스트와 튜플</li>
</ol>
<ul>
<li><p>개요 : 리스트와 튜플 모두 여러 데이터를 담는 컨테이너형 변수</p>
<blockquote>
<p>리스트 : []<br>튜플 : ()</p>
</blockquote>
</li>
<li><p>공통점</p>
<blockquote>
<p>인덱싱과 슬라이싱이 가능함<br>순회 가능 (iterable) : 리스트와 튜플 모두 for 문을 이용하여 순회 할 수 있음 : max, min 등 순회 가능 요소를 입력 받는 함수의 입력으로 사용할 수 있음</p>
</blockquote>
</li>
<li><p>차이점</p>
<blockquote>
<p>가변과 불편 : 리스트의 요소는 바꿀 수 있으나, 튜플은 안됨</p>
</blockquote>
<ul>
<li>리스트는 사전의 key로 사용할 수 없지만, 튜플은 사전의 key로 사용 가능함</li>
<li>불편의 자료형, int, float, str 등만 사전의 key로 사용 할 수 있다</li>
<li>조건 등을 입력으로, 해당 조건에 대응되는 값들을 출력으로 하는 사전 구축은 의외로 많은 데이터 전처리에서 사용한다.</li>
</ul>
</li>
<li><p>순회 속도</p>
<blockquote>
<p>리스트보다 튜플이 약간 더 빠름<br>요소를 변경할 필요 없고, 요소에 대한 연산 결과만 필요한 경우에는 리스트보다 튜플이 적합함<br>데이터가 큰 경우에 한해서, 리스트로 작업 후, 튜플로 자료형을 바꾼 후 순회함</p>
</blockquote>
</li>
<li><p>리스트 관련 함수</p>
<blockquote>
<p>요소 추가</p>
</blockquote>
<ul>
<li>append : 새로운 요소를 맨 뒤에 추가</li>
<li>insert : 새로운 요소 x를 a 위치에 추가</li>
</ul>
</li>
</ul>
<blockquote>
<p>요소 제거<br>    - remove : 기존 요소 x를 제거 (중복된 값이 있는 경우 앞에 있는 요소가 삭제 됨)<br>    - pop : 맨 마지막 요소를 출력하면서 그 요소를 삭제</p>
</blockquote>
<blockquote>
<p>위치 찾기<br>    - index : x의 위치를 반환</p>
</blockquote>
<blockquote>
<p>확장하기<br>    - List1 + List2 : 두 리스트를 그대로 이어 붙임(튜플도 가능)<br>    - List1.extend(List2) : 위와 상동</p>
</blockquote>
<ul>
<li>튜플 관련 함수<blockquote>
<p>튜플은 요소 변경이 불가하므로, 추가 및 제거 관련 함수를 지원하지 않음<br>소괄호를 쓰지 않아도 된다는 특징 덕분에, SWAP (값을 서로 변경), 함수의 가변인자 및 여러 개의 출력을 받는 데 많이 사용함</p>
</blockquote>
</li>
</ul>
<h4 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h4><pre>
<code>
# 리스트의 정의
L1 = [1, 2, 3, 4, 5]
L2 = ['a', 'b', 'c', 1, 2]
L3 = [1, 2, [3, 4]]
print(L1, L2, L3)

# 튜플의 정의
T1 = (1, 2, 3, 4, 5)
T2 = ('a', 'b', 'c', 1, 2)
T3 = (1, 2, (3, 4))
print(T1, T2, T3)
</code>
</pre>


<h4 id="리스트와-튜플의-공통점"><a href="#리스트와-튜플의-공통점" class="headerlink" title="리스트와 튜플의 공통점"></a>리스트와 튜플의 공통점</h4><pre>
<code>
# 인덱싱과 슬라이싱
L = [4, 5, 1, 2, 10, 6]
print("L[2] = &#123;&#125;".format(L[2]))
print("L[4] = &#123;&#125;".format(L[4]))
print("L[-1] = &#123;&#125;".format(L[-1]))
print("L[0:3] = &#123;&#125;".format(L[0:3]))
print("L[:3] = &#123;&#125;".format(L[:3])) 
print("L[2:] = &#123;&#125;".format(L[2:]))
print("L[0:4:2] = &#123;&#125;".format(L[0:4:2]))

print("~~~~&#123;&#125;, &#123;&#125;".format(2, 4))

# for문을 이용한 순회
L = [1, 2, 3, 4, 5]
T = (1, 2, 3, 4, 5)

print("List 순회")
for val in L:
    print(val ** 2)

print("\nTuple 순회")
for val in T:
    print(val ** 2)
</code>
</pre>

<h4 id="리스트와-튜플의-차이점"><a href="#리스트와-튜플의-차이점" class="headerlink" title="리스트와 튜플의 차이점"></a>리스트와 튜플의 차이점</h4><pre>
<code>
# 리스트의 요소 변경
L = [1, 2, 3, 4, 5]
print(L)
L[0] = 10
print(L)

# 튜플은 요소 변경 불가

# 순회 속도 비교하기
large_L = list(range(100000))
large_T = tuple(range(100000))

import time
time.time()

# 리스트 순회 속도 측정
import time
start_time = time.time()
for val1 in large_L:
    pass
end_time = time.time()
print(end_time - start_time)

# 튜플 순회 속도 측정
start_time = time.time()
for val2 in large_T:
    pass
end_time = time.time()
print(end_time - start_time)
</code>
</pre>

<h4 id="리스트-관련-함수"><a href="#리스트-관련-함수" class="headerlink" title="리스트 관련 함수"></a>리스트 관련 함수</h4><pre>
<code>
# 요소 추가 함수: append
L1 = [4, 5, 1, 2, 10]
L1.append(15)
print(L1)

# 요소 추가 함수: insert
L2 = [4, 5, 1, 2, 10]
L2.insert(1, 7)
print(L2)

# 요소 제거 함수: remove
L3 = [1, 3, 2, 1, 4]
L3.remove(1)
print(L3)
# 단 리스트 안에 없는 함수는 제거할 수 없다


# 요소 제거 + 제거한 함수 같이 출력하는  함수: pop
L4 = [4, 5, 1, 2, 10]
print(L4.pop())
print(L4)

# 위치 찾기 함수: index
L5 = [1, 3, 2, 1, 4]
print("1의 위치:&#123;&#125;".format(L5.index(1)))
print("3의 위치:&#123;&#125;".format(L5.index(3)))

L5.index(5) # 5의 위치: 없으므로 Error 발생 (5 is not in list)
</code>
</pre>

<h4 id="튜플-관련-함수"><a href="#튜플-관련-함수" class="headerlink" title="튜플 관련 함수"></a>튜플 관련 함수</h4><pre>
<code>
# 소괄호없이 튜플 만들기
T = 1, 2, 3, 4
print(T)

# 원소가 하나인 튜플은 반드시 원소 뒤에 쉼표를 붙여야 함
T = 1,
print(type(T))

# 튜플을 이용한 여러 값 동시에 입력받기 및 Swap
a, b = 1, 2 # a = 1; b = 2
print(a, b)
b, a = a, b # Swap
print(a, b)

# 함수의 가변 인자로 사용
def f(*x): # *: 인자수가 정해지지 않았음을 의미
    print("입력된 데이터의 타입:&#123;&#125;".format(type(x)))
    sum_x = 0
    product_x = 1
    for val in x:
        sum_x += val
        product_x *= val
    return sum_x, product_x

S, P = f(1, 2, 3, 4, 5) # 출력을 각각 S와 P로 받음
print(S, P)
</pre>
</code>

<ol start="4">
<li>사전</li>
</ol>
<ul>
<li><p>개요 : 키(key)와 값(value) 쌍으로 이루어진 해시 테이블(hash table)</p>
<blockquote>
<p>키(key) : 불편의 값<br>값(value) : 불편 혹은 가변에 상관없이 사용<br>순서 상관 없음<br>dic = {key1 : value1, key2 : value2 … }</p>
</blockquote>
</li>
<li><p>사전 요소에 접근하기 및 바꾸기</p>
<blockquote>
<p>접근하기 : dict[key]<br>요소 변경 및 추가 : dict[key] = new value<br>요소 삭제 : del(dict[key])</p>
</blockquote>
</li>
<li><p>사전 관련 함수 : 요소 확인하기</p>
<blockquote>
<p>키 리스트 받기 : .key()<br>값 리스트 받기 : .values()<br>key, value 쌍 얻기 : .items()<br>위 함수들은 주로 값을 효율적으로 순회하거나 변경할 때 주로 사용됨</p>
</blockquote>
</li>
</ul>
<pre>
<code>
# 사전 생성하기
dic = &#123;1:1, 2:4, 3:9, 4:16&#125;
print(dic[1]) # 사전 요소 접근하기

dic[5] = 20 # 새로운 요소 추가
print(dic[5])

dic[5] = 25 # 요소 변경
print(dic[5])

# 사전 관련 함수: 요소 확인하기
print(dic.keys())
print(dic.values())
print(dic.items())

# 순회 예시
for key, val in dic.items():
    print(key, val)

# 값 변경 예시
for key in dic.keys():
    dic[key] = dic[key] * 0.5

print(dic)
</code>
</pre>

<ol start="5">
<li>for문과 comprehension</li>
</ol>
<ul>
<li>반복문 기초<blockquote>
<p>for문 기초 문법</p>
</blockquote>
<ul>
<li>for element in iterator : 순회 가능한 자료형(리스트, 튜플 등)의 요소를 순서대로 element에 저장하여 특정 구문을 반복함</li>
<li>break : 현재 속한 반복문을 중지시키며, 보통 if문과 같이 사용</li>
</ul>
</li>
</ul>
<blockquote>
<p>대표적인 이터레이터 객체 생성 함수<br>    - 이터레이터 객체는 값을 차례대로 꺼낼 수 있는 객체를 의미 (리스트, 튜플)<br>    - range, itertools 모듈에 있는 주요 함수 등을 통해서도 이터레이터를 생성할 수 있음</p>
</blockquote>
<blockquote>
<p>range(start, end, step)<br>    - start 인덱스 부터 end 인덱스 까지 step 으로 건너 뛴 부분 이터레이터 객체를 반환<br>    - 값이 하나면 end로 인식<br>    - 값이 두 개면 start와 end로 인식</p>
</blockquote>
<blockquote>
<p>itertools 모듈 함수<br>    - itertools.product(L) : 순회 가능한 여러 개의 객체를 순서대로 순회하는 이터레이터<br>    - itertools.combinations(p, r) : 이터레이터 객체 p에서 크기 r의 가능한 모든 조합을 갖는 이터레이터를 생성<br>    - itertools.permutations(p, r) : 이터레이터 객체 p에서 크기 r의 가능한 모든 순열을 갖는 이터레이터를 생성</p>
</blockquote>
<blockquote>
<p>comprehension<br>    - for문을 사용하여 한 줄로 리스트를 효과적으로 생성하는 방법<br>    - output for element in iterator if 조건<br>    - 조건문은 생략 가능</p>
</blockquote>
<blockquote>
<p>dictionary comprehension<br>    - for문을 사용하여 한 줄로 사전을 효과적으로 생성하는 방법<br>    - {key : value for key, val in iterator if 조건}</p>
</blockquote>
<h4 id="for문-기초-예제"><a href="#for문-기초-예제" class="headerlink" title="for문 기초 예제"></a>for문 기초 예제</h4><pre>
<code>
L = [1, 2, 3, 4, 5]

for l in L:
    print(l)
    if l == 3:
        break

for x in range(1, 5, 2):
    print(x)

# range 함수를 사용한 구구단 
# nested for문
for i in range(2, 10):
    for j in range(1, 10):
        print("&#123;&#125;*&#123;&#125;=&#123;&#125;".format(i, j, i*j))
    print('\n')
</code>
</pre>

<h4 id="itertools-모듈-사용-예제"><a href="#itertools-모듈-사용-예제" class="headerlink" title="itertools 모듈 사용 예제"></a>itertools 모듈 사용 예제</h4><pre>
<code>
import itertools

# itertools.product 예제
count = 0
for a, b, c in itertools.product(range(5), range(5), range(5)):
    print(a, b, c)

# 위 코드와 같은 방식으로 동작하는 코드
for a in range(5):
    for b in range(5):
        for c in range(5):
            print(a, b, c)

for a, b, c in zip(range(5), range(5), range(5)):
    print(a, b, c)

# itertools.combination 예제
# L에서 2개로 이뤄진 가능한 모든 조합 뽑기
L = ['a', 'b', 'c', 'd']
for comb in itertools.combinations(L, 2):
    print(comb)

# L에서 가능한 모든 조합 뽑기
for r in range(1, len(L) + 1):
    for comb in itertools.combinations(L, r):
        print(comb)

# L에서 가능한 모든 순열 뽑기
for r in range(1, len(L)):
    for comb in itertools.permutations(L, r):
        print(comb)
</code>
</pre>

<h4 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h4><pre>
<code>
L1 = [x for x in range(10)]
L1

L1 = []
for x in range(10):
    L1.append(x)
L1

L2 = [x**2 for x in range(10)]
L2

L3 = [x**2 for x in range(10) if x%2 == 0]
L3

L3 = []
for x in range(10):
    if x%2 == 0:
        L3.append(x**2)
L3

X = [1, 2, 3, 'a', 'b']
Y = [3, 1, 2, 'c', 4]

L4 = [x + y for x, y in itertools.product(X, Y) if type(x) == type(y) == int]
L4
</code>
</pre>

<h4 id="dictionary-comprehension"><a href="#dictionary-comprehension" class="headerlink" title="dictionary comprehension"></a>dictionary comprehension</h4><pre>
<code>
dic1 = &#123;x:y for x, y in zip(range(10), range(10))&#125;
dic1

dic = &#123;1:'NaN', 2:2, 3:4, 4:'NaN'&#125;
dic2 = &#123;x:y for x, y in dic.items() if y != 'NaN'&#125;
dic2

dic2 = dict()
for x, y in dic.items():
    if y != 'NaN':
        dic2[x] = y
</code>
</pre>

<ol start="6">
<li>Numpy의 데이터 구조</li>
</ol>
<ul>
<li><p>개요 : Numpy의 자료형은 ndarray로 효율적인 배열 연산을 하기 위해 개발되었음</p>
</li>
<li><p>리스트와 ndarray는 유연성과 효율성을 기준으로 비교할 수 있음</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>유연성</th>
<th>효율성</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>서로 다른 데이터 타입의 요소를 담을 수 있음</td>
<td>각 요소 정보를 따로 저장함, 반복문 사용이 필수적임</td>
</tr>
<tr>
<td>ndarray</td>
<td>서로 다른 데이터 타입의 요소를 담을 수 없음</td>
<td>모든 요소 정보를 한 번에 저장, C로 구현된 내부 반복문을 사용하여 속도가 매우 빠름</td>
</tr>
</tbody></table>
<ul>
<li><p>배열 만들기</p>
<blockquote>
<p>np.array 함수<br>다양한 함수</p>
</blockquote>
<ul>
<li>np.zeros(shape) : shape (튜플) 모양을 갖는 영벡터/영행렬 생성</li>
<li>np.arange(start, stop, step)</li>
<li>np.linspace(start, stop, num)</li>
</ul>
</li>
<li><p>인덱싱과 슬라이싱</p>
<blockquote>
<p>기본적인 인덱싱과 슬라이싱은 리스트 자료형과 완전히 동일함<br>2차원 배열인 경우, X[i, j]는 i행 j열에 있는 요소를 나타냄<br>부울 리스트도 인덱스로 사용할 수 있으며, True인 요소와 대응되는 요소만 가져옴<br>여러 개의 인덱스를 리스트 형태로 입력받을 수도 있음</p>
</blockquote>
</li>
<li><p>유니버설 함수</p>
<blockquote>
<p>ndarray의 개별 요소에 반복된 연산을 빠르게 수행하는 것을 주 목적으로 하는 함수<br>ndarray x와 y에 대해, 덧셈 뺄셈 곱셈 제곱 등 다양한 배열 간 이항 연산을 지원함<br>단순 반복문에 비해, 매우 빠름</p>
</blockquote>
</li>
<li><p>브로드캐스팅</p>
<blockquote>
<p>다른 크기의 배열에 유니버설 함수를 적용하는 규칙 집합으로 큰 차원의 배열에 맞게 작은 배열이 확장됨</p>
</blockquote>
</li>
<li><p>비교 연산자</p>
<blockquote>
<p>비교 연산자의 결과는 항상 부울 타입의 배열임<br>비교 연산자의 결과를 바탕으로 조건에 맞는 요소 탐색에 활용</p>
</blockquote>
</li>
</ul>
<h4 id="배열-만들기"><a href="#배열-만들기" class="headerlink" title="배열 만들기"></a>배열 만들기</h4><pre>
<code>
# 리스트에서 배열 만들기
import numpy as np

a = np.array([1, 4, 2, 5, 3])
b = np.array([3.14, 4, 2, 3])
c = np.array([1, 2, 3, 4], dtype = float)

print(a, b, c)

# 함수를 이용하여 배열 만들기
a = np.zeros(10, dtype = int) # 0으로 채운 배열 생성
b = np.ones((3, 5), dtype = float) #1로 채운 배열 생성
c = np.full((3,5), 3.14) # 3.14로 채운 배열 만들기
d = np.arange(0, 20, 2) # 0에서 시작해 2씩 더해 20까지 채우는 배열 생성
e = np.linspace(0, 1, 5) # 0과 1 사이에 일정한 간격을 가진 다섯 개의 값으로 채운 배열 만들기
f = np.random.random((3,3)) # 3x3 크기의 난수 배열 생성
g = np.random.normal(0, 1, (3, 3)) # 평균 0, 표준 편차 1의 정규 분포를 따르는 3*3 난수 배열
h = np.random.randint(0, 10, (3, 3)) # [0, 10) 구간의 임의로 정수로 채운 3*3 배열 만들기
i = np.eye(3) # 크기 3의 단위 행렬 만들기

print("np.zeros(10, dtype = int):\n", a)
print("\nnp.ones((3, 5), dtype = float):\n", b)
print("\nnp.full((3,5), 3.14):\n", c)
print("\nnp.arange(0, 20, 2):\n", d)
print("\nnp.linspace(0, 1, 5):\n", e)
print("\nnp.random.random((3,3)):\n", f)
print("\nnp.random.normal(0, 1, (3, 3)):\n", g)
print("\nnp.random.randint(0, 10, (3, 3)):\n", h)
print("\nnp.eye(3):\n", i)

#결과
np.zeros(10, dtype = int):
 [0 0 0 0 0 0 0 0 0 0]

np.ones((3, 5), dtype = float):
 [[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]

np.full((3,5), 3.14):
 [[3.14 3.14 3.14 3.14 3.14]
 [3.14 3.14 3.14 3.14 3.14]
 [3.14 3.14 3.14 3.14 3.14]]

np.arange(0, 20, 2):
 [ 0  2  4  6  8 10 12 14 16 18]

np.linspace(0, 1, 5):
 [0.   0.25 0.5  0.75 1.  ]

np.random.random((3,3)):
 [[0.76280637 0.82939832 0.69987398]
 [0.52054864 0.16380557 0.72284064]
 [0.5007331  0.92089446 0.54809238]]

np.random.normal(0, 1, (3, 3)):
 [[-0.21360243  0.02910364 -0.25599073]
 [ 0.78425474 -1.62196936  0.5722869 ]
 [ 1.24378832  0.91543034 -1.20984274]]

np.random.randint(0, 10, (3, 3)):
 [[7 3 6]
 [6 6 4]
 [4 4 0]]

np.eye(3):
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
</code>
</pre>

<h4 id="인덱싱과-슬라이싱"><a href="#인덱싱과-슬라이싱" class="headerlink" title="인덱싱과 슬라이싱"></a>인덱싱과 슬라이싱</h4><pre>
<code>
# 기본적인 인덱싱과 슬라이싱
x1 = np.array([1, 3, 5, 7, 9])

print("x1[0]:", x1[0]) # 양수 인덱스 (맨 앞 요소)
print("x1[3]:", x1[3]) # 세 번째 요소
print("x1[-1]:", x1[-1]) # 음수 인덱스 (맨 뒤 요소)
print("x1[-2]:", x1[-2]) # 뒤에서 네 번째 요소

print("x1[1:3]:", x1[1:3]) # 1번째 요소부터 3번째 요소까지 슬라이싱

# 2차원 배열의 인덱싱 및 슬라이싱
x2 = np.random.random(size = (10, 5))

print("x2[0, 1]", x2[0, 1])
print("x2[1:4, 2]\n", x2[1:4, 2])
print("x2[0, 2:4]\n", x2[0, 2:4])
print("x2[0:3, 2:4]\n", x2[0:3, 2:4])
</code>
</pre>

<h4 id="유니버셜-함수"><a href="#유니버셜-함수" class="headerlink" title="유니버셜 함수"></a>유니버셜 함수</h4><pre>
<code>
# 사용 기초
x = np.array([1, 2, 3, 4])
y = np.array([4, 3, 2, 1])

print("x + y = ", x + y)
print("x - y = ", x - y)
print("x * y = ", x * y)
print("x / y = ", x / y)
print("log x = ", np.log(x))

# 루프와 유니버설 함수의 속도 비교
arr_1 = np.random.randint(1, 10, size = 10 ** 8)
arr_2 = np.random.randint(1, 10, size = 10 ** 8)

import time

### 리스트를 사용하여 벡터의 덧셈 구현
t1 = time.time()
output = []

for val1, val2 in zip(arr_1, arr_2):
    output.append(val1 + val2)

t2 = time.time()

print("반복문을 사용한 경우:", round(t2 - t1, 4))

### 유니버설 함수를 사용하여 벡터의 덧셈 구현
t1 = time.time()
output = arr_1 + arr_2

t2 = time.time()

print("유니버설 함수를 사용한 경우:", round(t2 - t1, 4))

# 브로드캐스팅
print("np.arange(3) + 5:",
      np.arange(3) + 5, '\n')

print("np.ones((3, 3)) + np.arange(3)\n",
      np.ones((3, 3)) + np.arange(3), '\n')

print("np.arange(3).reshape(3, 1) + np.arange(3)\n",
      np.arange(3).reshape(3, 1) + np.arange(3))

# 브로드캐스팅 예시: z - normalization
X = np.random.random((10, 3))
Xmean = X.mean(axis = 0) # 열별 평균 크기: (1, 3)
Xstd = X.std(axis = 0) # 열별 표준편차 크기: (1, 3)

Z = (X - Xmean) / Xstd

print("X:", X)
print("\nXmean:\n", Xmean)
print("\nXstd:\n", Xstd)
print("\nZ:\n", Z)
</code>
</pre>

<h4 id="비교-연산"><a href="#비교-연산" class="headerlink" title="비교 연산"></a>비교 연산</h4><pre>
<code>
L = np.array([1, 2, 3, 4, 5])
L >= 3

# 비교 연산자
L = np.array([1, 2, 3, 4, 5])
cond = L >= 3
sum(cond) # 조건을 만족하는 요소의 개수
# True = 1, False = 0

L[cond] # 조건을 만족하는 요소만 반환
</code>
</pre>

<ol start="7">
<li>Pandas의 데이터 구조</li>
</ol>
<ul>
<li><p>자료형 1. Series</p>
<blockquote>
<p>1차원 배열 자료형으로 인덱스와 값의 쌍으로 구성 : 사전을 이용한 정의/ 리스트를 이용한 정의<br>ndarray에 인덱스가 부여된 형태의 데이터<br>유니버설 함수와 브로드캐스팅 등이 적용됨</p>
</blockquote>
</li>
<li><p>자료형 2. DataFrame</p>
<blockquote>
<p>DataFrame은 2차원 배열 자료형으로 값, 행 인덱스, 열 인덱스로 구성 : 사전을 이용한 정의/ 리스트를 이용한 정의<br>ndarray에 행과 열 인덱스가 부여된 형태의 데이터<br>하나 이상의 Series의 집합이라고 볼 수 있음</p>
</blockquote>
</li>
<li><p>인덱싱과 슬라이싱</p>
<blockquote>
<p>명식적 인덱스 : loc 인덱서 : 맨 뒤 값 포함<br>암묵적 인덱스(위치) : iloc 인덱서 : 맨 뒤 값 포함하지 않음</p>
</blockquote>
</li>
<li><p>값 조회하기</p>
<blockquote>
<p>pd.set_option()<br>데이터 크기 때문에, 아래 함수를 사용하여 데이터의 일부만 확인하거나 요약 정보를 확인하는 것이 바람직함</p>
</blockquote>
<ul>
<li>.head(n)</li>
<li>.tail(n)</li>
<li>.columns :L 컬럼명 집합</li>
<li>.dtypes : 컬럼별 데이터 타입</li>
</ul>
</li>
<li><p>값 변경하기</p>
<blockquote>
<p>리스트와 동일</p>
</blockquote>
</li>
</ul>
<h4 id="Series의-기본"><a href="#Series의-기본" class="headerlink" title="Series의 기본"></a>Series의 기본</h4><pre>
<code>
import pandas as pd

S = pd.Series(&#123;"a" : 1, "b" : 2, "c" : 3, "d" : 4&#125;)
S = pd.Series([1, 2, 3, 4], index = ['a', 'b', 'c', 'd'])
#결과
a    1
b    2
c    3
d    4

S = pd.Series([1, 2, 3, 4])
# 결과
0    1
1    2
2    3
3    4

type(S.values)

S ** 2 # 유니버설 함수와 브로드캐스팅이 적용됨
</code>
</pre>

<h4 id="DataFrame-기본"><a href="#DataFrame-기본" class="headerlink" title="DataFrame 기본"></a>DataFrame 기본</h4><pre>
<code>
df = pd.DataFrame(&#123;"col1": [1, 2, 3, 4],
                  "col2": [5, 6, 7, 8]&#125;,
                  index = ['a', 'b', 'c', 'd'])

type(df.values)
</code>
</pre>

<h4 id="인덱싱과-슬라이싱-1"><a href="#인덱싱과-슬라이싱-1" class="headerlink" title="인덱싱과 슬라이싱"></a>인덱싱과 슬라이싱</h4><pre>
<code>
S.loc['a'] # 사전에서 키를 가지고 값을 찾는 것과 완벽히 동일

df[['col1', 'col2']] # column name list => Data Frame

df.loc['a':'c', 'col1']
df.iloc[1:3, 1]
</code>
</pre>

<h4 id="값-조회하기"><a href="#값-조회하기" class="headerlink" title="값 조회하기"></a>값 조회하기</h4><pre>
<code>
# 모든 행과 모든 열을 보여주기
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)

import numpy as np
df = pd.DataFrame(np.random.random(size = (500, 5)),
                 columns = ['X1', 'X2', 'X3', 'X4', 'X5'])

df.columns
df.dtypes

# 값 변경하기
df.iloc[3, 4] = 'Changed'
df.head()

df.iloc[3:20, 2:4] = 'Changed2'
df.iloc[:25]
</code>
</pre>

<ol start="8">
<li>재료 준비하기 : 데이터 불러오기</li>
</ol>
<ul>
<li>경로 확인하기 및 설정하기<blockquote>
<p>파이썬에서 파일 불러오기 : 경로와 확장자까지 포함<br>os 모듈에 속한 함수 사용하여 경로 확인</p>
</blockquote>
<ul>
<li>os.getcwd() : 현재 경로를 반환</li>
<li>os.chdir(path) : 현재 경로를 path로 설정</li>
</ul>
</li>
</ul>
<blockquote>
<p>경로 설정 tip<br>    - 데이터 속성 : 위치 혹은 주소창에 있는 경로를 복사해서 붙여넣어 손쉽게 경로를 설정<br>    - 역슬래시()</p>
</blockquote>
<ul>
<li><p>txt, csv, tsv 데이터 불러오기</p>
<blockquote>
<p>open 함수 : 파일 객체 = open(파일 경로 및 이름, 모드)<br>정제되지 않은 형태의 데이터를 불러오는 경우 주로 사용함<br>모드</p>
</blockquote>
<ul>
<li>r(default) : 읽기</li>
<li>w : 쓰기 (새로운 파일을 생성하여 씀)</li>
<li>a : 추가 (기존 파일에 새로운 내용을 씀)</li>
</ul>
</li>
<li><p>read와 readline을 이용하여 데이터 불러오기</p>
<blockquote>
<p>f.read()<br>f.readline() : 파일 f에 있는 한 줄을 불러옴<br>read 및 readline의 결과물은 문자열</p>
</blockquote>
<ul>
<li>str.split(sep)</li>
<li>map(함수, L)</li>
</ul>
</li>
<li><p>write 함수를 사용하여 내용 쓰기</p>
<blockquote>
<p>f.write(string) : string을 파일 f에 씀<br>리스트 등을 string으로 변환하는join 함수를 활용하면 효율적으로 파일을 쓸 수 있음</p>
</blockquote>
<ul>
<li>sep.join(list) : 리스트의 문자열 요소들을 sep으로 연결</li>
</ul>
</li>
<li><p>read_csv 함수를 이용한 데이터 불러오기</p>
<blockquote>
<p>테이블 형태의 데이터를 불러오는 데 효과적<br>filepath : 파일 경로 및 이름<br>sep : 구분자<br>header : 헤더의 위치로 None을 입력하면 컬럼명이 0, 1, 2, …<br>index_col : 인덱스의 위치<br>usecols : 사용할 컬럼 목록 및 위치 목록<br>nrows : 불러올 행의 개수</p>
</blockquote>
</li>
<li><p>to_csv함수를 이용한 데이터 저장하기</p>
<blockquote>
<p>filepath : 파일 경로 및 이름<br>sep : 구분자<br>index : 인덱스를 저장할지 여부</p>
</blockquote>
</li>
<li><p>read_excel 함수를 이용한 데이터 불러오기</p>
<blockquote>
<p>.xlsx 포맷의 데이터를 불러오는데 효과적인 함수<br>filepath : 파일 경로 및 이름<br>sheet_name : 불러오고자 하는 시트 이름 및 위치<br>header : 헤더의 위치로 None을 입력하면 컬럼명이 0, 1, 2, …<br>index_col : 인덱스의 위치<br>usecols : 사용할 컬럼 목록 및 위치 목록<br>nrows : 불러올 행의 개수<br>skiprows : 불러오지 않을 행의 위치(리스트)</p>
</blockquote>
</li>
<li><p>to_excel함수를 이용한 데이터 저장하기</p>
<blockquote>
<p>filepath : 파일 경로 및 이름<br>index : 인덱스를 저장할지 여부<br>sheet_name : 불러오고자 하는 시트 이름 및 위치</p>
</blockquote>
<ul>
<li>df.to_excel(filepath, index, sheet_name, mode)</li>
</ul>
</li>
</ul>
<blockquote>
<p>여러 시트를 생성해야 하는 경우 ExcelWriter 사용<br>    - pd.ExcelWriter(xlsx file)</p>
</blockquote>
<h4 id="경로-확인하"><a href="#경로-확인하" class="headerlink" title="경로 확인하"></a>경로 확인하</h4><pre>
<code>
import os
os.getcwd() # 현재 경로 확인

os.chdir(r"C:\Users\user\Downloads")

open("sample folder/sample data.txt")
</code>
</pre>

<h4 id="read-를-이용한-데이터-불러오기"><a href="#read-를-이용한-데이터-불러오기" class="headerlink" title="read()를 이용한 데이터 불러오기"></a>read()를 이용한 데이터 불러오기</h4><pre>
<code>
f = open("data_reading.csv", "r")
data = f.read()
f.close()
data[:1000]

# list comprehension을 이용한 데이터 정제
# 숫자로 바꿀 수 있는 것은 바꾸기 위한 함수 (첫 줄에는 문자이므로)
def make_float(x):
    try:
        return float(x)
    except:
        return x

data = [[make_float(value) for value in line.split(',')] for line in data.split('\n')]
data

new_data = []

for line in data.split('\n'):
    new_line = []
    for value in line.split(','):
        new_line.append(make_float(value))
    new_data.append(new_line)

new_data
</code>
</pre>

<h4 id="readline을-이용한-데이터-불러오기"><a href="#readline을-이용한-데이터-불러오기" class="headerlink" title="readline을 이용한 데이터 불러오기"></a>readline을 이용한 데이터 불러오기</h4><pre>
<code>
f = open("data_reading.csv", "r")
header = f.readline() # 첫 번째 row를 읽어옴
data = []

line = f.readline() # 두 번째 row를 읽음
while line: # line이 빈 문자열이 될 때까지
    data.append(list(map(float, line.split(','))))
    line = f.readline()
f.close()
</code>
</pre>

<h4 id="write를-이용한-데이터-쓰기"><a href="#write를-이용한-데이터-쓰기" class="headerlink" title="write를 이용한 데이터 쓰기"></a>write를 이용한 데이터 쓰기</h4><pre>
<code>
','.join(list(map(str, data[2])))

# f = open("written_data.csv", "w")

# 파일 열고 닫기를 동시에 해줌
with open("written_data.csv", "w") as f:
    f.write(header)
    for line in data:
        f.write(','.join(list(map(str, line))))
        f.write('\n')

# f.close()
##########
</code>
</pre>

<h4 id="csv-데이터-불러오기"><a href="#csv-데이터-불러오기" class="headerlink" title="csv 데이터 불러오기"></a>csv 데이터 불러오기</h4><pre>
<code>
df = pd.read_csv("data_reading.csv")
df.head()

df = pd.read_csv("data_reading_tap.txt", sep = "\t")
df.head()

# header를 설정하지 않은 경우
df = pd.read_csv("data_reading_without_header.csv")
df.head()

df = pd.read_csv("data_reading_without_header.csv", header = None)
df.head()

df.columns = ['X1', 'X2', 'X3', 'X4', 'X5']
df.head() # 컬럼명 바꾸기
</code>
</pre>

<h4 id="큰-규모의-데이터-불러오기"><a href="#큰-규모의-데이터-불러오기" class="headerlink" title="큰 규모의 데이터 불러오기"></a>큰 규모의 데이터 불러오기</h4><pre>
<code>
df = pd.read_csv("large_data_with_ID.csv",
                 usecols = [0, 1, 5, 10], # ['ID', 'X1', 'X5', 'X10']으로 불러와도 무방
                index_col = 'ID', # usecols을 사용하는 경우, index_col을 반드시 포함시켜야 함
                nrows = 1000)

df.head()
</code>
</pre>

<h4 id="to-csv를-이용한-데이터-저장하기"><a href="#to-csv를-이용한-데이터-저장하기" class="headerlink" title="to_csv를 이용한 데이터 저장하기"></a>to_csv를 이용한 데이터 저장하기</h4><pre>
<code>
df = pd.DataFrame(&#123;"A":[1,2,3],
                  "B":[4,5,6]&#125;,
                  index = ['a', 'b', 'c'])

df

df.to_csv("to_csv를 이용한 데이터 저장_인덱스미포함.csv", sep = ",", index = False)
__
</code>
</pre>

<h4 id="read-excel을-사용한-데이터-불러오기-기초"><a href="#read-excel을-사용한-데이터-불러오기-기초" class="headerlink" title="read_excel을 사용한 데이터 불러오기 기초"></a>read_excel을 사용한 데이터 불러오기 기초</h4><pre>
<code>
# 시트를 정의하지 않으면, 첫 번째 시트가 불러와짐
df = pd.read_excel("data_reading.xlsx")
df

# 시트 지정하기
df = pd.read_excel("data_reading.xlsx", sheet_name = 'target_sheet')
df.head()

# 필요한 부분 데이터 불러오기
df = pd.read_excel("월별매출데이터.xlsx", sheet_name = '6월', skiprows = range(6))
df = df.iloc[:, 1:] # 첫 번째 컬럼이 불필요하므로 제거
df.head()

# to_excel을 이용한 데이터 저장
df1 = pd.DataFrame(&#123;"A":[1,2,3,4], "B":[5,6,7,8]&#125;)
df2 = pd.DataFrame(&#123;"A":[9,10,11,12], "B":[13,14,15,16]&#125;)

with pd.ExcelWriter('written_excel.xlsx') as writer:
    df1.to_excel(writer, sheet_name='First')
    df2.to_excel(writer, sheet_name='Second')
</code>
</pre>

<ol start="9">
<li>데이터 통합 및 집계</li>
</ol>
<ul>
<li><p>merge가 필요한 상황</p>
<blockquote>
<p>SQL : join, Python : merge<br>left<br>right<br>on : 통합 기준 key 변수 및 변수 리스트<br>left_on : 통합 대상 데이터 프레임1의 key 변수 및 변수 리스트<br>right_on<br>left_index : 통합 대상 데이터 프레임1의 인덱스를 key 변수로 사용할 지 여부<br>right_index</p>
</blockquote>
</li>
<li><p>concat이 필요한 상황</p>
<blockquote>
<p>센서, 로그, 거래 데이터 등과 같이 크기가 매우 큰 데이터는 시간과 ID 등에 따라 분할되어 저장<br>통합해야 하는 데이터가 많은 경우 빈 데이터 프레임을 생성한 뒤, 이 데이터프레임과 반복문을 사용하여 불러온 데이터를 concat 함수를 이용하면 효율적<br>둘 이상의 데이터 프레임을 이어 붙이는 데 사용하는 함수<br>objs : DataFrame을 요소로 하는 리스트로 입력 순서대로 병합이 됨<br>ignore_index : True면 기존 인덱스를 무시하고 새로운 인덱스를 부여하며, False면 기존 인덱스를 사용<br>axis : 0이면 행 단위로 병합을 수행하며, 1이면 열 단위로 병합을 수행<br>os.listdir(path) : path 상에 있는 모든 파일명을 리스트 형태로 반환<br>xlrd를 이용한 엑셀 시트 목록 가져오기</p>
</blockquote>
<ul>
<li>wb = xlrd.open_workbook(file, on_demand = True) # 엑셀 파일을 불러와 wb에 저장</li>
</ul>
</li>
<li><p>기초 통계 함수를 사용한 데이터 집계</p>
<blockquote>
<p>다양한 기초 통계 함수 : DataFrame와 Series에 대해 모두 정의됨</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>함수</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>sum</td>
<td>합계</td>
</tr>
<tr>
<td>mean</td>
<td>평균</td>
</tr>
<tr>
<td>std</td>
<td>표준편차</td>
</tr>
<tr>
<td>var</td>
<td>분산</td>
</tr>
<tr>
<td>quantile</td>
<td>사분위수</td>
</tr>
<tr>
<td>min</td>
<td>최소값</td>
</tr>
<tr>
<td>max</td>
<td>최대값</td>
</tr>
</tbody></table>
<blockquote>
<p>axis를 설정해서 행별 혹은 열별 기초 통계를 구할 수 있음<br>    - axis가 0이면 행을 1이면 열을 나타나지만, 결과 구조가 벡터 형태인지 행렬 형태인지에 따라 역할이 다르다.</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>결과</th>
<th>결과</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>백터</td>
<td>행렬</td>
</tr>
<tr>
<td>axis</td>
<td>0</td>
<td>결과가 행벡터</td>
<td>연산 과정이 행 기준</td>
</tr>
<tr>
<td>axis</td>
<td>1</td>
<td>결과가 열벡터</td>
<td>연산 과정이 열 기준</td>
</tr>
</tbody></table>
<blockquote>
<p>describe 함수 : 열별로 대표적인 기초 통계를 반환(count, mean, std, min, 15%, 50%, 75%, max)</p>
</blockquote>
<ul>
<li><p>pivot을 활용한 데이터 집계</p>
<blockquote>
<p>조건에 따른 변수들의 통계량을 요약한 테이블<br>행 단위의 데이터 프레임을 피벗 테이블로 변환하는 함수<br>data : 데이터 프레임<br>index : 행에 들어갈 조건<br>columns : 열에 들어갈 조건<br>values : 집계 대상 컬럼 목록<br>aggfunc : 집계 함수</p>
</blockquote>
</li>
<li><p>group by를 활용한 데이터 집계</p>
<blockquote>
<p>조건부 통계량을 계산하기 위한 방법으로 크게 분할, 적용, 결합으로 구성<br>DataFrame.groupby : 분할 기준 컬럼을 기준으로 나누는 함수<br>사용 구조 : df.groupby(분할기준 칼럼)[적용 기준 칼럼].집계 함수<br>by : 분할 기준 컬럼 (목록)<br>as_index : 분할 기준 컬럼들을 인덱스로 사용할 것인지<br>여러 개의 집게 함수나 사용자 정의 함수를 쓰고 싶다면 agg 함수 사용<br>pivot table(한 눈에 보임) vs groupby(중간 산출물)</p>
</blockquote>
</li>
</ul>
<h4 id="merge-기초"><a href="#merge-기초" class="headerlink" title="merge 기초"></a>merge 기초</h4><pre>
<code>
# Tip. OSError: Initializing from file failed가 발생하면 engine = "python"을 설정하면 피할 수 있음 (단, 속도 저하 문제가 있음)
df1 = pd.read_csv("merge_실습_employee_group.csv", engine = "python")
df2 = pd.read_csv("merge_실습_employee_hire_date.csv", engine = "python")
__
merged_df = pd.merge(df1, df2) # 컬럼명이 같아서 키를 employee로 인식함
merged_df.head()
</code>
</pre>

<h4 id="on을-사용한-경우"><a href="#on을-사용한-경우" class="headerlink" title="on을 사용한 경우"></a>on을 사용한 경우</h4><pre>
<code>
merged_df = pd.merge(df1, df2, on = ["employee"])
merged_df.head()

df1 = pd.read_csv("merge_실습_employee_group.csv", engine = "python")
df2 = pd.read_csv("merge_실습_name_hire_date.csv", engine = "python")

# 컬럼명을 바꿔도 똑같이 작동함
merged_df = pd.merge(df1, df2, left_on = "employee", right_on = "name")
merged_df.head() # employee와 name 모두 살아 있어서, 하나를 제거해줘야 함
__
merged_df.drop('name', axis = 1, inplace = True)
merged_df.head()
</code>
</pre>

<h4 id="index를-사용한-데이터-통합"><a href="#index를-사용한-데이터-통합" class="headerlink" title="index를 사용한 데이터 통합"></a>index를 사용한 데이터 통합</h4><pre>
<code>
df1 = pd.read_csv("merge_실습_employee_group.csv", engine = "python")
df2 = pd.read_csv("merge_실습_name_hire_date.csv", engine = "python", index_col = "name")
__
merged_df = pd.merge(df1, df2, left_on = "employee", right_index = True)
</code>
</pre>

<h4 id="concat-기초"><a href="#concat-기초" class="headerlink" title="concat 기초"></a>concat 기초</h4><pre>
<code>
df1 = pd.DataFrame(&#123;"A":[1,2,3,4], "B":[1,2,3,4]&#125;)
df2 = pd.DataFrame(&#123;"A":[5,6,7,8], "B":[5,6,7,8]&#125;)

merged_df = pd.concat([df1, df2], axis = 0, ignore_index = True)
merged_df

df1 = pd.DataFrame(&#123;"A":[1,2,3,4], "B":[5,6,7,8]&#125;)
df2 = pd.DataFrame(&#123;"C":[1,2,3,4], "D":[5,6,7,8]&#125;)

merged_df = pd.concat([df1, df2], axis = 1, ignore_index = False)
merged_df

df1 = pd.read_csv("일별 오염 데이터/2004-03-14_오염_수준.txt", sep = "\t", engine = "python")
df2 = pd.read_csv("일별 오염 데이터/2004-03-20_오염_수준.txt", sep = "\t", engine = "python")
__

os.listdir("일별 오염 데이터")
# for문을 이용한 데이터 병합
# (코드가 김, 상대적으로 비효율적임, 메모리 문제가 생길 가능성이 적음)
merged_df = pd.DataFrame() # 빈 데이터 프레임 생성

for file in os.listdir("일별 오염 데이터"):
    if '오염_수준.txt' in file:
        df = pd.read_csv("일별 오염 데이터/" + file, sep = "\t", engine = "python")
        merged_df = pd.concat([merged_df, df], axis = 0, ignore_index = True)

merged_df.head()

# list comprehension을 이용한 데이터 통합
# (코드가 짧음, 효율적임, 메모리 문제가 생길 수 있음)
merged_df = pd.concat([pd.read_csv("일별 오염 데이터/" + file, sep = "\t", engine = "python")
                       for file in os.listdir("일별 오염 데이터") if '오염_수준.txt' in file])
__

import xlrd

wb = xlrd.open_workbook("월별매출데이터.xlsx", on_demand = True)
sheetnames = wb.sheet_names()
sheetnames

merged_df = pd.DataFrame()
for sn in sheetnames:
    df = pd.read_excel("월별매출데이터.xlsx", sheet_name = sn, skiprows = range(6))
    df = df.iloc[:, 1:] # 첫 번째 컬럼이 불필요하므로 제거
    merged_df = pd.concat([merged_df, df], axis = 0, ignore_index = True)
merged_df

# list comprehension을 이용한 데이터 통합
merged_df = pd.concat([pd.read_excel("월별매출데이터.xlsx", sheet_name = sn, skiprows = range(6)).iloc[:, 1:] for sn in sheetnames])
merged_df.shape
</code>
</pre>

<h4 id="기초-통계-함수를-이용한-데이터-집계"><a href="#기초-통계-함수를-이용한-데이터-집계" class="headerlink" title="기초 통계 함수를 이용한 데이터 집계"></a>기초 통계 함수를 이용한 데이터 집계</h4><pre>
<code>
df[['수량', '판매금액']].mean()

df[['수량', '판매금액']].quantile(0.1)

df[['수량', '판매금액']].describe()
</code>
</pre>

<h4 id="pivot을-이용한-데이터-집계"><a href="#pivot을-이용한-데이터-집계" class="headerlink" title="pivot을 이용한 데이터 집계"></a>pivot을 이용한 데이터 집계</h4><pre>
<code>
pt1 = pd.pivot_table(df, index = '제품', columns = '쇼핑몰 유형', values = '판매금액', aggfunc = 'mean')
pt1

pt2 = pd.pivot_table(df, index = ['제품'], columns = ['쇼핑몰 유형'], values = ['판매금액', '수량'], aggfunc = 'max')
pt2
</code>
</pre>

<h4 id="groupby를-이용한-데이터-집계"><a href="#groupby를-이용한-데이터-집계" class="headerlink" title="groupby를 이용한 데이터 집계"></a>groupby를 이용한 데이터 집계</h4><pre>
<code>
df.groupby(['쇼핑몰 유형'])['수량'].mean()

df.groupby(['쇼핑몰 유형'], as_index = False)['수량'].mean()

df.groupby(['쇼핑몰 유형'])['수량', '판매금액'].agg(['mean', 'max'])

def my_func(value):
    return max(value) - min(value)

df.groupby(['쇼핑몰 유형', '제품'])['수량', '판매금액'].agg(my_func)
</code>
</pre>

<ol start="10">
<li>보고 싶은 데이터 찾아보기</li>
</ol>
<ul>
<li><p>데이터 정렬</p>
<blockquote>
<p>리스트 및 튜플 정렬</p>
</blockquote>
<ul>
<li>sort : 리스트 및 튜플 자체 정렬 (return 값 없음) &gt; Pandas에서 inplace =True로 설정할 것과 같음 &gt; reverse : 내림차순으로 정렬할 것인지 여부</li>
<li>sorted : 정렬된 리스트 및 튜플을 반환 &gt; reverse : 내림차순으로 정렬할 것인지 여부를 결정 &gt; key : 정렬 기준 함수 (주로 lambda 함수)</li>
</ul>
</li>
<li><p>Series 정렬</p>
<blockquote>
<p>sort_values를 사용하면 Series를 손쉽게 정렬할 수 있음<br>ascending : 오름차순 정렬<br>key : 정렬 기준 (주로 lambda 함수)<br>na_position ; 결측이 있는 경우 어디에 배치할 것인지 {first, last}</p>
</blockquote>
</li>
<li><p>Series 요약 함수</p>
<blockquote>
<p>value_counts : Series 구성 요소의 빈도를 순서대로 출력<br>ascending : 오름차순 정렬<br>normalize : 빈도 대신 비율을 출력할 것인지 여부<br>unique : Series에 포함된 유니크한 값 출력<br>출력 결과의 데이터 타입 : ndarray<br>범주형 변수와 연속형 변수를 판단하는 데 사용 가능</p>
</blockquote>
</li>
<li><p>DataFrame 정렬</p>
<blockquote>
<p>sort_values를 사용하면 DataFrame도 손쉽게 정렬할 수 있음<br>by : 정렬 기준 컬럼 (목록)<br>ascending : 오름차순 정렬<br>key : 정렬 기준 (주로 lambda 함수)<br>na_position ; 결측이 있는 경우 어디에 배치할 것인지 {first, last}</p>
</blockquote>
</li>
<li><p>DataFrame 중복 제거</p>
<blockquote>
<p>drop_duplicates 함수<br>subset : 중복 기준을 판단하는 컬럼<br>keep : 중복이 있는 행의 어느 부분을 남길 것인지 {first(첫 헹만 남기고), last(마지막 행만 남기고), false(중복된 행을 모두 제거)}</p>
</blockquote>
</li>
<li><p>인덱서를 활용한 인덱싱</p>
<blockquote>
<p>인덱싱과 슬라이싱</p>
</blockquote>
<ul>
<li>loc(명시적, 사용자 설정한 데이터 프레임 혹은 series의 인덱스)</li>
<li>iloc(암묵적, 0부터 시작하는)</li>
</ul>
</li>
</ul>
<blockquote>
<p>값 변경하기 : 인덱서를 사용하여 조회한 값을 직접 변경할 수 있음</p>
</blockquote>
<blockquote>
<p>인덱서를 사용해야 하는 이유<br>    - 데이터 프레임의 값을 바꾸는 경우 자주 보는 경고 : Setting With Copy Warning 경고<br>    - df[‘A’] : view 반환 : 원본 자체 변경 가능<br>    - df.loc[‘A’] : copy 반환 : 원본 변경 없음</p>
</blockquote>
<ul>
<li><p>마스킹 검색</p>
<blockquote>
<p>비교 연산 : Series와 DataFrame의 data가 모두 ndarray이므로 비교연산 및 브로드캐스팅이 적용 가능함<br>부울 리스트 연산 : and 연산(&amp;)과 or 연산(|) 가능<br>df.loc[부울 리스트] : True인 요소의 위치에 대응되는 행만 가져옴</p>
</blockquote>
</li>
<li><p>문자열 검색</p>
<blockquote>
<p>Series.str : 문자열로 구성된 Series에 대해 str accessor를 사용할 수 있으며, 이를 사용하면 string 관련 내장 함수를 자유 자재로 사용할 수 있음<br>Series.str.strip() : 앞 뒤 공백 제거<br>Series.str.contains(s) : 문자열 s를 포함하고 있는지 여부<br>Series.str.split(sep, expand) : sep을 기준으로 Series를 분할 : expand = True (새로운 열 생성) : expand = False (새로운 열을 생성하지 않고 리스트를 반환)<br>Series.astype : 자료형 변환</p>
</blockquote>
</li>
</ul>
<h4 id="리스트와-튜플의-정렬"><a href="#리스트와-튜플의-정렬" class="headerlink" title="리스트와 튜플의 정렬"></a>리스트와 튜플의 정렬</h4><pre>
<code>
# sort 함수 사용
L = [1, 4, 3, 5, 2, 5]
L.sort() # 출력이 None이고 L자체가 수정됨

L = [1, 4, 3, 5, 2, 5]
L.sort(reverse = True) # 출력이 None이고 L자체가 수정됨
L

# sorted 함수 사용
T = [(1, 2), (3, 1), (4, 5), (10, 4)]
sorted(T, key = lambda x:x[1]) # x에서 1번째 요소를 기준으로 정렬

L = [1, 4, 3, 5, 2, 5]
sorted(L, key = lambda x:abs(x-3)) # |x-3|을 기준으로 정렬

L = ['We', 'Use', 'Python', 'For', 'Data Preprocessing']
sorted(L, key = lambda x:len(x), reverse = True) # 길이를 기준으로 내림차순 정렬
</code>
</pre>

<h4 id="Series-정렬"><a href="#Series-정렬" class="headerlink" title="Series 정렬"></a>Series 정렬</h4><pre>
<code>
import pandas as pd
import numpy as np

S = pd.Series(np.random.randint(1, 10, 100)) # 1과 10 사이의 숫자를 100개 생성
S.iloc[0:3] = np.nan # 0부터 3까지를 결측으로 바꾸기

S.head(10)

S.sort_values()
# default: ascending = True, key = None, na_position = last

S.sort_values(ascending = False, na_position = 'first')

# 요약 함수
S.value_counts(normalize = True)

S.value_counts(normalize = True, ascending = True)

S.unique()

# dataframe 정렬
df = pd.DataFrame(&#123;"A":[1,2,3,1,2,3], "B":[3,2,1,3,2,1], "C":[1,2,3,4,3,2]&#125;)
df

df.sort_values(by = 'A', ascending = True) # A를 기준으로 오름차순 정렬

df.sort_values(by = ['C', 'B'], ascending = False) # C와 B를 기준으로 내림차순 정렬

df.drop_duplicates(subset = ['A']) # A 기준 중복 제거 (첫 행 남김: 인덱스 주목)

df.drop_duplicates(subset = ['A'], keep = 'last') # A 기준 중복 제거 (마지막 행 남김: 인덱스 주목)
</code>
</pre>

<h4 id="마스킹-검색"><a href="#마스킹-검색" class="headerlink" title="마스킹 검색"></a>마스킹 검색</h4><pre>
<code>
df['제품'] == '제품_16'
__

df['쇼핑몰 유형'].unique()
df.loc[df['쇼핑몰 유형'].isin(['온라인Il', '온라인사이트'])]

df.loc[(df['수량'] >= 5) & (df['쇼핑몰 유형'] == '전시회')]
</code>
</pre>

<h4 id="문자열-검색"><a href="#문자열-검색" class="headerlink" title="문자열 검색"></a>문자열 검색</h4><pre>
<code>
# 공정이 S인 제품의 개수
df['시리얼번호'].str.contains('S').sum()

df['시리얼번호'].str.split('-', expand = True).head() # 하이픈 기준 분할

# 분할한 데이터 붙이기
merged_df = pd.concat([df, df['시리얼번호'].str.split('-', expand = True)], axis = 1)
merged_df.head()

# 컬럼명 변경
merged_df.rename(&#123;0:"공정", 1:"제품", 2:"식별자"&#125;, axis = 1, inplace = True)
merged_df.head()

pd.pivot_table(merged_df.loc[merged_df['불량 여부'] != '양품'], values = '불량 여부', index = '공정', columns = '제품', aggfunc = 'count')
</code>
</pre>

<ol start="11">
<li>데이터 예쁘게 보이기 : 데이터 시각화</li>
</ol>
<ul>
<li><p>matplotlib</p>
<blockquote>
<p>line plot<br>scatter plot<br>bar chart<br>histogram<br>box plot</p>
</blockquote>
</li>
<li><p>기초 환경 설정 : pyplot.rcParams을 활용한 폰트 설정 및 그래프 크기 설정</p>
<blockquote>
<p>rcParams[‘font.family’] : 폰트 설정<br>rcParams[‘font.size’] : 글씨 크기 설정<br>rcParams[‘figure.figsize’] : (x,y) 꼴의 튜플로 그래프 크기 설정</p>
</blockquote>
</li>
<li><p>쥬피터에서 그래프 그리기</p>
<blockquote>
<p>%matplotlib inline : 셀에 그래프 직접 출력<br>plt.figure()<br>plt.savefig(file, dpi) : 그래프 저장</p>
</blockquote>
</li>
<li><p>자주 사용되는 색상 설정</p>
<blockquote>
<p>b(파)<br>g(녹)<br>r(빨)<br>y(노)<br>K(검)</p>
</blockquote>
</li>
<li><p>자주 사용되는 마커 및 선 스타일 설정</p>
<blockquote>
<p>마커 : 하나의 데이터 포인트를 나타내는 기호<br>선 스타일 : 꺾은선 그래프의 선 스타일</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>마커</th>
<th>입력</th>
</tr>
</thead>
<tbody><tr>
<td>점</td>
<td>.</td>
</tr>
<tr>
<td>픽셀</td>
<td>,</td>
</tr>
<tr>
<td>원</td>
<td>o</td>
</tr>
<tr>
<td>별</td>
<td>*</td>
</tr>
<tr>
<td>더하기</td>
<td>+</td>
</tr>
<tr>
<td>x</td>
<td>X</td>
</tr>
<tr>
<td>다이아몬드</td>
<td>D</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>선 스타일</th>
<th>입력</th>
</tr>
</thead>
<tbody><tr>
<td>실선</td>
<td>-</td>
</tr>
<tr>
<td>파선</td>
<td>–</td>
</tr>
<tr>
<td>파선-점선</td>
<td>-.</td>
</tr>
<tr>
<td>점선</td>
<td>:</td>
</tr>
</tbody></table>
<ul>
<li><p>label 및 title 설정</p>
<blockquote>
<p>label : 축의 이름 : plt.xlabel(label, **kwargs) : label(str)로 xlabel 설정<br>**kwargs : 텍스트의 특성을 설정하는 키워드<br>title이란 그래프의 이름으로, plt.title을 사용하여 정의 : plt.title(label, loc) : label(str)으로 title 설정 (loc : 위치 {center, left, right})</p>
</blockquote>
</li>
<li><p>tick 설정</p>
<blockquote>
<p>tick : 그래프에서 나타내는 눈금 : plt.xticks(ticks, labels) : ticks (위치)에 labels를 입력 (x축)</p>
</blockquote>
</li>
<li><p>legend 설정</p>
<blockquote>
<p>legend (범례)를 표시하려면 plt.legend(loc)을 사용하여 범례 표시<br>loc : 범례 위치 {upper right (1), …, lower left(3) … right(5), center(6)}<br>범례를 표시하려면 그래프를 그릴 때 label 키워드를 사용하여 범례 정의</p>
</blockquote>
</li>
<li><p>축 범위 설정</p>
<blockquote>
<p>plt.xlim(left, right) : x축의 범위를 (left, right)로 설정<br>plt.xlim(bottom, top) : y축의 범위를 (bottom, top)로 설정</p>
</blockquote>
</li>
<li><p>꺾은선 그래프 그리기</p>
<blockquote>
<p>matplotlib을 활용한 꺾은선 그래프</p>
</blockquote>
<ul>
<li>x, y</li>
<li>linewidth : 선 두께</li>
<li>marker : 마커 종류</li>
<li>markersize : 마커 크기</li>
<li>color : 선 색상</li>
<li>linestyle : 선 스타일</li>
<li>label : 범례</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pandas 객체의 method를 이용한 꺾은선 그래프<br>    - kind : 그래프 종류<br>    - x, y<br>    - xticks, yticks</p>
</blockquote>
<ul>
<li>산점도 그리기<blockquote>
<p>matplotlib을 활용한 산점도 그리기</p>
</blockquote>
<ul>
<li>x, y</li>
<li>marker : 마커 종류</li>
<li>markersize : 마커 크기</li>
<li>color : 선 색상</li>
<li>label : 범례</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pandas 객체의 method를 이용한 꺾은선 그래프<br>    - kind : 그래프 종류<br>    - x, y<br>    - xticks, yticks</p>
</blockquote>
<ul>
<li>막대 차트 그리기<blockquote>
<p>matplotlib을 활용한 막대 차트 그리기</p>
</blockquote>
<ul>
<li>x</li>
<li>height : 막대의 높이</li>
<li>width : 막대의 너비</li>
<li>align : 막대 정렬</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pandas 객체의 method를 이용한 꺾은선 그래프<br>    - kind : 그래프 종류<br>    - x, y<br>    - xticks, yticks</p>
</blockquote>
<blockquote>
<p>다중 막대 그리기 : groupby, set_index, unstack 혹은 pivot_table</p>
</blockquote>
<ul>
<li>파이 차트 그리기<blockquote>
<p>matplotlib을 활용한 막대 차트 그리기</p>
</blockquote>
<ul>
<li>x</li>
<li>labels : 각 pie에 부착되는 라벨</li>
<li>label distance : 라벨 간 거리</li>
<li>normalize : 비율을 나타낼 것인지 여부</li>
<li>autopct : 위에 표시될 글자 형태</li>
<li>colors : 배열로 설정해서 각 파트의 색상을 설정 가능</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pandas 객체의 method를 이용한 꺾은선 그래프<br>    - kind : 그래프 종류<br>    - x, y</p>
</blockquote>
<ul>
<li>박스 플롯<blockquote>
<p>하나의 변수에 대한 분포를 한 눈에 보여주는 그래프 : 최소 Q1 중위수 Q3 최대값 이상치<br>matplotlib을 활용한 막대 차트 그리기</p>
</blockquote>
<ul>
<li>x</li>
</ul>
</li>
</ul>
<blockquote>
<p>Pandas 객체의 method를 이용한 꺾은선 그래프<br>    - column : box plot을 그릴 컬럼 목록</p>
</blockquote>
<h4 id="꺽은-선-그래프"><a href="#꺽은-선-그래프" class="headerlink" title="꺽은 선 그래프"></a>꺽은 선 그래프</h4><pre>
<code>
# 기본 환경설정
from matplotlib import pyplot as plt
import numpy as np

%matplotlib inline
plt.rcParams["font.family"] = 'Malgun Gothic'
plt.rcParams["font.size"] = 20
plt.rcParams["figure.figsize"] = (30, 10)

# pyplot을 사용한 그래프 그리기
np.cumsum([1, 2, 3]) # 누적합 반환

# 그래프 기본 설정
plt.title("날짜별 상품 판매량")
plt.xlabel("날짜")
plt.ylabel("판매량 (개수)")

xtick_range = np.cumsum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30]) # 월별 일 수 누적을 통한 매월 1일 인덱스 정의 (12월 제외)
plt.xticks(xtick_range, df['날짜'].loc[xtick_range])

plt.plot(df['날짜'], df['상품1'], label = '상품1', color = 'b')
plt.plot(df['날짜'], df['상품2'], label = '상품2', color = 'g')
plt.plot(df['날짜'], df['상품3'], label = '상품3', color = 'r')

plt.legend()

# DataFrame을 이용하여 직접 그래프 그리기
# 그래프 기본 설정
xtick_range = np.cumsum([0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30]) # 월별 일 수 누적을 통한 매월 1일 인덱스 정의 (12월 제외)
df.plot(kind = 'line', x = '날짜', y = ['상품1', '상품2', '상품3'])

plt.title("날짜별 상품 판매량")
plt.xlabel("날짜")
plt.ylabel("판매량 (개수)")
plt.xticks(xtick_range, df['날짜'].loc[xtick_range]);

# groupby를 이용한 그래프 그리기
df['날짜'].str.split('-', expand = True).head()

df['월'] = df['날짜'].str.split('-', expand = True).iloc[:, 1]

df.groupby('월')[['상품1', '상품2', '상품3']].sum()

df.groupby('월')[['상품1', '상품2', '상품3']].sum().plot(kind = 'line') # default를 썼으므로, 인덱스가 x축으로 모든 컬럼이 y축으로 들어감
plt.title("날짜별 상품 판매량")
plt.xlabel("날짜")
plt.ylabel("판매량 (개수)")
plt.xticks(range(12), [str(i + 1) + '월' for i in range(12)]);
</code>
</pre>

<h1 id="산점도-그리기"><a href="#산점도-그리기" class="headerlink" title="산점도 그리기"></a>산점도 그리기</h1><pre>
<code>
from matplotlib import pyplot as plt
import numpy as np
%matplotlib inline
plt.rcParams["font.family"] = 'Malgun Gothic'
plt.rcParams["font.size"] = 20
plt.rcParams["figure.figsize"] = (40, 15)

'1' + '2'
# 결과 : '12'

# 년도 - 분기를 잇는 새로운 변수 생성
df['분기'] = df['년도(year)'].astype(str) + '-' + df['분기(4)'].astype(str)
df['분기'].head()

grouped_df = df.groupby(['분기', '대리점'], as_index = False)['수량'].sum()
grouped_df

# pyplot을 이용한 그래프 그리기
# 그래프 기본 설정

plt.figure(figsize=(16,10));
plt.title("날짜 및 대리점별 출하량")
plt.xlabel("분기")
plt.ylabel("출하량 (개수)")

xtick_range = range(len(grouped_df['분기'].unique()))
xtick_label = grouped_df['분기'].unique()
plt.xticks(xtick_range, xtick_label)

for agent in grouped_df['대리점'].unique():
    cond = grouped_df['대리점'] == agent
    plt.scatter(grouped_df.loc[cond]['분기'], grouped_df.loc[cond]['수량'], s = 100, marker = '*')

# DataFrame을 이용하여 직접 그래프 그리기
pivot_df = pd.pivot_table(data = grouped_df, values = '수량', index = '분기', columns = '대리점', aggfunc = 'sum')
pivot_df = pivot_df.add_suffix("_출하량") # 대리점명이 전부 컬럼으로 되기 때문에, suffix를 추가시킴

pivot_df
__

pivot_df['분기'] = list(range(len(pivot_df))) # x축에 쓰기 위해 임의의 변수를 생성함
pivot_df['분기'].head()

# 그래프 기본 설정
pivot_df.plot(kind = 'scatter', x = '분기', y = '대리점 1_출하량')

plt.title("날짜별 상품 판매량")
plt.xlabel("분기")
plt.ylabel("출하량 (개수)")

xtick_range = range(len(grouped_df['분기'].unique()))
xtick_label = grouped_df['분기'].unique()

plt.xticks(xtick_range, xtick_label);
</code>
</pre>

<h4 id="막대-차트-그리기"><a href="#막대-차트-그리기" class="headerlink" title="막대 차트 그리기"></a>막대 차트 그리기</h4><pre>
<code>
# 제품군별 수량합계 계산
grouped_df1 = df.groupby(['제품군'], as_index = False)['수량'].sum()
grouped_df1

# 그래프 기본 설정
from matplotlib import pyplot as plt
import numpy as np
%matplotlib inline
plt.rcParams["font.family"] = 'Malgun Gothic'
plt.rcParams["font.size"] = 20
plt.rcParams["figure.figsize"] = (10, 8)

# 제품군별 출하량 합계 계산
plt.title("제품군별 출하량 합계")
plt.xlabel("제품군")
plt.ylabel("출하량 합계 (개수)")
plt.bar(grouped_df1['제품군'], grouped_df1['수량'], width = 0.5)

# 다중 bar chart 그리기
plt.rcParams["figure.figsize"] = (40, 15)
grouped_df2 = df.groupby(['제품군', '년도(year)'], as_index = True)['수량'].sum()
grouped_df2

grouped_df2.unstack().plot(kind = 'bar', figsize=(12,8));
</code>
</pre>

<h4 id="파이-차트-그리기"><a href="#파이-차트-그리기" class="headerlink" title="파이 차트 그리기"></a>파이 차트 그리기</h4><pre>
<code>
# 제품군별 수량합계 계산
grouped_df = df.groupby(['제품군'], as_index = False)['수량'].sum()

# 기타 행 추가
other_row = pd.DataFrame(&#123;"제품군":['기타'],
                          '수량':[grouped_df.sort_values(by = '수량')['수량'].iloc[:4].sum()]&#125;)

grouped_df = pd.concat([grouped_df, other_row], axis = 0, ignore_index = True)
grouped_df = grouped_df.sort_values(by = '수량', ascending = False).iloc[:3]
grouped_df

# 그래프 기본 설정
from matplotlib import pyplot as plt
import numpy as np
%matplotlib inline
plt.rcParams["font.family"] = 'Malgun Gothic'
plt.rcParams["font.size"] = 15
plt.rcParams["figure.figsize"] = (10, 8)

# 제품군별 출하량 합계 계산
plt.title("제품군별 출하량 비율")

plt.pie(x = grouped_df['수량'],
        labels = grouped_df['제품군'],
       labeldistance = 0.3,
       autopct = '%1.1f%%');
</code>
</pre>

<h4 id="박스-플롯-그리기"><a href="#박스-플롯-그리기" class="headerlink" title="박스 플롯 그리기"></a>박스 플롯 그리기</h4><pre>
<code>
# 그래프 기본 설정
from matplotlib import pyplot as plt
import numpy as np
%matplotlib inline
plt.rcParams["font.family"] = 'Malgun Gothic'
plt.rcParams["font.size"] = 15
plt.rcParams["figure.figsize"] = (15, 8)

# pyplot을 이용한 boxplot 그리기
X = df.groupby(['쇼핑몰 유형'])['판매금액'].apply(list) # 쇼핑몰 유형에 따른 판매 금액 목록을 리스트화
X

plt.title("쇼핑몰 유형에 따른 판매금액 분포")
plt.boxplot(X.values)
plt.xticks(np.arange(1, len(X)+1), X.index);

# DataFrame method를 이용한 boxplot 그리기
df = pd.DataFrame(&#123;"실험1": np.random.normal(10, 2, size = 100),
                  "실험2": np.random.normal(8, 3, size = 100),
                  "실험3": np.random.normal(9, 4, size = 100)&#125;)
df.head()

df.boxplot(column = ['실험1', '실험2', '실험3'], figsize=(12,8));
</code>
</pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/machine/" rel="tag"># machine</a>
              <a href="/tags/learning/" rel="tag"># learning</a>
              <a href="/tags/data/" rel="tag"># data</a>
              <a href="/tags/handling/" rel="tag"># handling</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/29/machine-learning-4/" rel="prev" title="머신러닝  4편">
      <i class="fa fa-chevron-left"></i> 머신러닝  4편
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/16/machine-learning-6/" rel="next" title="머신러닝  6편">
      머신러닝  6편 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B0%9C%EC%9A%94"><span class="nav-number">1.</span> <span class="nav-text">개요</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8A%9C%ED%94%8C%EC%9D%98-%EA%B3%B5%ED%86%B5%EC%A0%90"><span class="nav-number">2.</span> <span class="nav-text">리스트와 튜플의 공통점</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8A%9C%ED%94%8C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90"><span class="nav-number">3.</span> <span class="nav-text">리스트와 튜플의 차이점</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98"><span class="nav-number">4.</span> <span class="nav-text">리스트 관련 함수</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8A%9C%ED%94%8C-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98"><span class="nav-number">5.</span> <span class="nav-text">튜플 관련 함수</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for%EB%AC%B8-%EA%B8%B0%EC%B4%88-%EC%98%88%EC%A0%9C"><span class="nav-number">6.</span> <span class="nav-text">for문 기초 예제</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#itertools-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%A0%9C"><span class="nav-number">7.</span> <span class="nav-text">itertools 모듈 사용 예제</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-comprehension"><span class="nav-number">8.</span> <span class="nav-text">List comprehension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dictionary-comprehension"><span class="nav-number">9.</span> <span class="nav-text">dictionary comprehension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="nav-number">10.</span> <span class="nav-text">배열 만들기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%9D%B8%EB%8D%B1%EC%8B%B1%EA%B3%BC-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EC%8B%B1"><span class="nav-number">11.</span> <span class="nav-text">인덱싱과 슬라이싱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%9C%A0%EB%8B%88%EB%B2%84%EC%85%9C-%ED%95%A8%EC%88%98"><span class="nav-number">12.</span> <span class="nav-text">유니버셜 함수</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0"><span class="nav-number">13.</span> <span class="nav-text">비교 연산</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Series%EC%9D%98-%EA%B8%B0%EB%B3%B8"><span class="nav-number">14.</span> <span class="nav-text">Series의 기본</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataFrame-%EA%B8%B0%EB%B3%B8"><span class="nav-number">15.</span> <span class="nav-text">DataFrame 기본</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EC%9D%B8%EB%8D%B1%EC%8B%B1%EA%B3%BC-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EC%8B%B1-1"><span class="nav-number">16.</span> <span class="nav-text">인덱싱과 슬라이싱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B0%92-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0"><span class="nav-number">17.</span> <span class="nav-text">값 조회하기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B2%BD%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98"><span class="nav-number">18.</span> <span class="nav-text">경로 확인하</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0"><span class="nav-number">19.</span> <span class="nav-text">read()를 이용한 데이터 불러오기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readline%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0"><span class="nav-number">20.</span> <span class="nav-text">readline을 이용한 데이터 불러오기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%93%B0%EA%B8%B0"><span class="nav-number">21.</span> <span class="nav-text">write를 이용한 데이터 쓰기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#csv-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0"><span class="nav-number">22.</span> <span class="nav-text">csv 데이터 불러오기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%81%B0-%EA%B7%9C%EB%AA%A8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0"><span class="nav-number">23.</span> <span class="nav-text">큰 규모의 데이터 불러오기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#to-csv%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0"><span class="nav-number">24.</span> <span class="nav-text">to_csv를 이용한 데이터 저장하기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-excel%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EA%B8%B0%EC%B4%88"><span class="nav-number">25.</span> <span class="nav-text">read_excel을 사용한 데이터 불러오기 기초</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge-%EA%B8%B0%EC%B4%88"><span class="nav-number">26.</span> <span class="nav-text">merge 기초</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#on%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EA%B2%BD%EC%9A%B0"><span class="nav-number">27.</span> <span class="nav-text">on을 사용한 경우</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#index%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%B5%ED%95%A9"><span class="nav-number">28.</span> <span class="nav-text">index를 사용한 데이터 통합</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concat-%EA%B8%B0%EC%B4%88"><span class="nav-number">29.</span> <span class="nav-text">concat 기초</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%B8%B0%EC%B4%88-%ED%86%B5%EA%B3%84-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A7%91%EA%B3%84"><span class="nav-number">30.</span> <span class="nav-text">기초 통계 함수를 이용한 데이터 집계</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pivot%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A7%91%EA%B3%84"><span class="nav-number">31.</span> <span class="nav-text">pivot을 이용한 데이터 집계</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#groupby%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A7%91%EA%B3%84"><span class="nav-number">32.</span> <span class="nav-text">groupby를 이용한 데이터 집계</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8A%9C%ED%94%8C%EC%9D%98-%EC%A0%95%EB%A0%AC"><span class="nav-number">33.</span> <span class="nav-text">리스트와 튜플의 정렬</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Series-%EC%A0%95%EB%A0%AC"><span class="nav-number">34.</span> <span class="nav-text">Series 정렬</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A7%88%EC%8A%A4%ED%82%B9-%EA%B2%80%EC%83%89"><span class="nav-number">35.</span> <span class="nav-text">마스킹 검색</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89"><span class="nav-number">36.</span> <span class="nav-text">문자열 검색</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EA%BA%BD%EC%9D%80-%EC%84%A0-%EA%B7%B8%EB%9E%98%ED%94%84"><span class="nav-number">37.</span> <span class="nav-text">꺽은 선 그래프</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%82%B0%EC%A0%90%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B8%B0"><span class="nav-number"></span> <span class="nav-text">산점도 그리기</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%A7%89%EB%8C%80-%EC%B0%A8%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B8%B0"><span class="nav-number">1.</span> <span class="nav-text">막대 차트 그리기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%ED%8C%8C%EC%9D%B4-%EC%B0%A8%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B8%B0"><span class="nav-number">2.</span> <span class="nav-text">파이 차트 그리기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EB%B0%95%EC%8A%A4-%ED%94%8C%EB%A1%AF-%EA%B7%B8%EB%A6%AC%EA%B8%B0"><span class="nav-number">3.</span> <span class="nav-text">박스 플롯 그리기</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">limjiin</p>
  <div class="site-description" itemprop="description">All stories about git, sql, python</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/limjiin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limjiin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:limjiin0413@gmail.com" title="E-Mail → mailto:limjiin0413@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.naver.com/lljin0413" title="Blog → https:&#x2F;&#x2F;blog.naver.com&#x2F;lljin0413" rel="noopener" target="_blank"><i class="fab fa-blog fa-fw"></i>Blog</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/ji_in_l" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;ji_in_l" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">limjiin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jin.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://limjiin.github.io/2021/11/15/machine-learning-5/";
    this.page.identifier = "2021/11/15/machine-learning-5/";
    this.page.title = "머신러닝  5편";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://jin.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
